#! /bin/sh
#
# If these # comments don't work, trim them. Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config_h.SH file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# (Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# The dist-3.0 package (which contains metaconfig) was posted in
# comp.sources.misc and is available on CPAN under authors/id/RAM so
# you may fetch it yourself from your nearest archive site.)
#

# $Id: Head.U 1.3 Mon, 10 Nov 2003 14:51:32 -0600 dunemush $
#
# Generated on Mon Sep 11 02:11:00 EDT 2006 [metaconfig 3.0 PL70]

cat >/tmp/c1$$ <<EOF
ARGGGHHHH!!!!!

SCO csh still thinks true is false.  Write to SCO today and tell them that next
year Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)

(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
we'd have to do is go in and swap the && and || tokens, wherever they are.)

[End of diatribe. We now return you to your regularly scheduled programming...]
EOF
cat >/tmp/c2$$ <<EOF

OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...
EOF

true || cat /tmp/c1$$ /tmp/c2$$
true || exec sh $0 $argv:q

(exit $?0) || cat /tmp/c2$$
(exit $?0) || exec sh $0 $argv:q
rm -f /tmp/c1$$ /tmp/c2$$

: compute my invocation name
me=$0
case "$0" in
*/*)
	me=`echo $0 | sed -e 's!.*/\(.*\)!\1!' 2>/dev/null`
	test "$me" || me=$0
	;;
esac

: Proper PATH separator
p_=:
: On OS/2 this directory should exist if this is not floppy only system :-]
if test -d c:/.; then
	: Check for cygwin32 emulation
	case "x$OSTYPE$OS" in
	x*msys*Windows*)
		echo 'Running on Windows? Using the MinGW MSys tools...'
		;;
	x*win32*)
		echo 'Running on Windows?  Assuming cygwin32 emulation tools...'
		;;
	x*windows*)
		echo 'Running on Windows?  Assuming cygwin32 emulation tools...'
		;;
	x*cygwin*)
		echo 'Looks like cygwin32...'
		;;
	x*)
		p_=\;
		PATH=`cmd /c "echo %PATH%" | tr '\\\\' / `
		OS2_SHELL=`cmd /c "echo %OS2_SHELL%" | tr '\\\\' / | tr '[A-Z]' '[a-z]'`
		;;
	esac
fi

: Proper PATH setting
paths='/bin /usr/bin /usr/local/bin /usr/ucb /usr/local /usr/lbin'
paths="$paths /opt/bin /opt/local/bin /opt/local /opt/lbin"
paths="$paths /usr/5bin /etc /usr/gnu/bin /usr/new /usr/new/bin /usr/nbin"
paths="$paths /opt/gnu/bin /opt/new /opt/new/bin /opt/nbin"
paths="$paths /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb"
paths="$paths /bsd4.3/usr/bin /usr/bsd /bsd43/bin /usr/ccs/bin"
paths="$paths /etc /usr/lib /usr/ucblib /lib /usr/ccs/lib"
paths="$paths /sbin /usr/sbin /usr/libexec /gnuwin32/b18/H-i386-cygwin32/bin"

case "x$OSTYPE$OS" in
	x*msys*Windows*)
		PATH='/usr/local/bin:/mingw/bin:/bin:/perl/bin'
		;;
	x*)
		for p in $paths
		do
			case "$p_$PATH$p_" in
				*$p_$p$p_*) ;;
				*) test -d $p && PATH=$PATH$p_$p ;;
			esac			
		done

		PATH=.$p_$PATH
		export PATH
		;;
esac

: shall we be using ksh?
inksh=''
needksh=''
avoidksh=''
newsh=/bin/ksh
changesh=''
if (PATH=.; alias -x) >/dev/null 2>&1; then
		inksh=true
fi
if test -f /hp-ux -a -f /bin/ksh; then
	needksh='to avoid sh bug in "here document" expansion'
fi
if test -d /usr/lpp -a -f /usr/bin/bsh -a -f /usr/bin/uname; then
	if test X`/usr/bin/uname -v` = X4; then
		avoidksh="to avoid AIX 4's /bin/sh"
		newsh=/usr/bin/bsh
	fi
fi
case "$inksh/$needksh" in
/[a-z]*)
		unset ENV
		changesh=true
		reason="$needksh"
	;;
esac
case "$inksh/$avoidksh" in
true/[a-z]*)
	changesh=true
	reason="$avoidksh"
	;;
esac
case "$inksh/$needksh-$avoidksh-" in
true/--)
		cat <<EOM
(I see you are using the Korn shell.  Some ksh's blow up on $me,
mainly on older exotic systems.  If yours does, try the Bourne shell instead.)
EOM
	;;
esac
case "$changesh" in
true)
	echo "(Feeding myself to $newsh $reason.)"
	case "$0" in
	Configure|*/Configure) exec $newsh $0 "$@";;
	*) exec $newsh Configure "$@";;
	esac
	;;
esac

: Configure runs within the UU subdirectory
test -d UU || mkdir UU
unset CDPATH
cd UU && rm -f ./*

d_bsd=''
d_eunice=''
d_xenix=''
eunicefix=''
Mcc=''
ar=''
awk=''
bash=''
bison=''
byacc=''
cat=''
chgrp=''
chmod=''
chown=''
comm=''
compress=''
cp=''
cpio=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
find=''
flex=''
gcc=''
grep=''
gzip=''
inews=''
ksh=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
make=''
mkdir=''
more=''
mv=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
shar=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uptime=''
uuname=''
vi=''
zcat=''
zip=''
hint=''
myuname=''
osname=''
osvers=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
archobjs=''
firstmakefile=''
cc=''
gccversion=''
ccflags=''
cppflags=''
ldflags=''
lkflags=''
locincpth=''
optimize=''
warnings=''
cdecl=''
cf_email=''
cf_name=''
cf_by=''
cf_time=''
contains=''
cpplast=''
cppminus=''
cpprun=''
cppstdin=''
d_gettblsz=''
nofile=''
tablesize=''
d_access=''
d_argsinfp=''
d_assert=''
d_attribut=''
d_bcopy=''
d_bindtextdomain=''
d_bzero=''
d_const=''
cryptlib=''
d_crypt=''
i_crypt=''
d_force_ipv4=''
d_fpsetmask=''
d_fpsetround=''
i_floatingpoint=''
d_gaistr=''
d_getadinf=''
d_getdate=''
d_gethbynm2=''
d_getnminf=''
d_getpagsz=''
pagesize=''
d_getprior=''
d_gettext=''
d_gnulibc=''
d_huge=''
d_huge_val=''
d_int_max=''
d_maxdouble=''
d_maxint=''
d_ieee=''
d_in2p=''
d_internet=''
d_ipv6=''
d_itimer=''
d_keepsig=''
d_memcpy=''
d_memmove=''
d_memset=''
d_newstyle=''
d_open3=''
d_portable=''
d_lrand48=''
d_rand=''
d_random=''
d_rename=''
d_rlimit=''
d_rusage=''
d_select=''
d_sendmail=''
d_setlocale=''
d_setpgid=''
d_bsdsetpgrp=''
d_setpgrp=''
d_setprior=''
d_sigaction=''
d_sigchld=''
d_sigcld=''
d_signalproto=''
d_sigprocmask=''
d_snprintf=''
d_oldsock=''
d_socket=''
d_sockpair=''
sockethdr=''
socketlib=''
d_socklen=''
d_strccmp=''
d_index=''
d_strchr=''
d_strcoll=''
d_strdup=''
d_strxfrm=''
d_sysconf=''
d_sysctl=''
d_sysctlbyname=''
d_tcl=''
i_tcl=''
d_textdomain=''
d_timelocal=''
d_toupper=''
d_uptime=''
d_urandom=''
d_uwait3=''
d_uwait=''
d_voidsig=''
signal_t=''
d_volatile=''
d_vsnprintf=''
d_waitpid=''
h_fcntl=''
h_sysfile=''
i_arpainet=''
i_arpanameser=''
i_errno=''
i_syserrno=''
i_fcntl=''
i_libintl=''
i_limits=''
i_locale=''
i_malloc=''
i_memory=''
i_netdb=''
i_niin=''
i_sysin=''
i_nitcp=''
i_setjmp=''
i_stddef=''
i_stdlib=''
i_string=''
strings=''
i_sysfile=''
d_voidtty=''
i_bsdioctl=''
i_sysfilio=''
i_sysioctl=''
i_syssockio=''
i_sysmman=''
i_syspage=''
i_sysparam=''
i_sysresrc=''
i_sysselct=''
i_syssock=''
i_sysstat=''
i_systypes=''
i_sysvlimit=''
i_syswait=''
i_sgtty=''
i_termio=''
i_termios=''
i_systime=''
i_systimek=''
i_time=''
timeincl=''
i_unistd=''
i_values=''
i_stdarg=''
i_varargs=''
i_varhdr=''
install=''
installdir=''
libc=''
d_mysql=''
libmysqlclient=''
glibpth=''
libpth=''
loclibpth=''
plibpth=''
xlibpth=''
libs=''
d_openssl=''
libssl=''
lns=''
mailer=''
make_set_make=''
d_mymalloc=''
freetype=''
mallocobj=''
mallocsrc=''
malloctype=''
usemymalloc=''
mydomain=''
myhostname=''
phostname=''
c=''
n=''
d_berknames=''
d_passnames=''
d_usgnames=''
nametype=''
groupcat=''
hostcat=''
passcat=''
package=''
spackage=''
pidtype=''
prototype=''
sh=''
sizetype=''
so=''
d_keepalive=''
d_keepidle=''
sharpbang=''
shsharp=''
spitshell=''
src=''
startsh=''
sysman=''
nm_opt=''
nm_so_opt=''
runnm=''
usenm=''
incpath=''
mips=''
mips_type=''
usrinc=''
defvoidused=''
voidflags=''
CONFIG=''

define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist=''

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
	eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
	eunicefix=/etc/unixtovms.exe
fi

: list of known cpp symbols, sorted alphabetically
al="AMIX BIT_MSF BSD BSD4_3 BSD_NET2 CMU CRAY DGUX DOLPHIN DPX2"
al="$al GO32 GOULD_PN HP700 I386 I80960 I960 Lynx M68000 M68K MACH"
al="$al MIPSEB MIPSEL MSDOS MTXINU MULTIMAX MVS"
al="$al M_COFF M_I186 M_I286 M_I386 M_I8086 M_I86 M_I86SM"
al="$al M_SYS3 M_SYS5 M_SYSIII M_SYSV M_UNIX M_XENIX"
al="$al NeXT OCS88 OSF1 PARISC PC532 PORTAR POSIX"
al="$al PWB R3000 RES RISC6000 RT Sun386i SVR3 SVR4"
al="$al SYSTYPE_BSD SYSTYPE_SVR4 SYSTYPE_SYSV Tek4132 Tek4300"
al="$al UMAXV USGr4 USGr4_2 UTEK UTS UTek UnicomPBB UnicomPBD Utek"
al="$al VMS Xenix286"
al="$al _AIX _AIX32 _AIX370 _AM29000 _COFF _CRAY _CX_UX _EPI"
al="$al _IBMESA _IBMR2 _M88K _M88KBCS_TARGET"
al="$al _MIPSEB _MIPSEL _M_COFF _M_I86 _M_I86SM _M_SYS3"
al="$al _M_SYS5 _M_SYSIII _M_SYSV _M_UNIX _M_XENIX _NLS _PGC_ _R3000"
al="$al _SYSTYPE_BSD _SYSTYPE_BSD43 _SYSTYPE_SVR4"
al="$al _SYSTYPE_SYSV _SYSV3 _U370 _UNICOS"
al="$al __386BSD__ __BIG_ENDIAN __BIG_ENDIAN__ __BSD_4_4__"
al="$al __DGUX__ __DPX2__ __H3050R __H3050RX"
al="$al __LITTLE_ENDIAN __LITTLE_ENDIAN__ __MACH__"
al="$al __MIPSEB __MIPSEB__ __MIPSEL __MIPSEL__"
al="$al __Next__ __OSF1__ __PARAGON__ __PGC__ __PWB __STDC__"
al="$al __SVR4_2__ __UMAXV__"
al="$al ____386BSD____ __alpha __alpha__ __amiga"
al="$al __bsd4_2 __bsd4_2__ __bsdi__ __convex__"
al="$al __host_mips__"
al="$al __hp9000s200 __hp9000s300 __hp9000s400 __hp9000s500"
al="$al __hp9000s500 __hp9000s700 __hp9000s800"
al="$al __hppa __hpux __hp_osf __i286 __i286__ __i386 __i386__"
al="$al __i486 __i486__ __i860 __i860__ __ibmesa __ksr1__ __linux__"
al="$al __m68k __m68k__ __m88100__ __m88k __m88k__"
al="$al __mc68000 __mc68000__ __mc68020 __mc68020__"
al="$al __mc68030 __mc68030__ __mc68040 __mc68040__"
al="$al __mc88100 __mc88100__ __mips __mips__"
al="$al __motorola__ __osf__ __pa_risc __sparc__ __stdc__"
al="$al __sun __sun__ __svr3__ __svr4__ __ultrix __ultrix__"
al="$al __unix __unix__ __uxpm__ __uxps__ __vax __vax__"
al="$al _host_mips _mips _unix"
al="$al a29k aegis aix aixpc alliant alpha am29000 amiga ansi ardent"
al="$al apollo ardent att386 att3b"
al="$al bsd bsd43 bsd4_2 bsd4_3 bsd4_4 bsdi bull"
al="$al cadmus clipper concurrent convex cray ctix"
al="$al dmert encore gcos gcx gimpel gould"
al="$al hbullx20 hcx host_mips hp200 hp300 hp700 hp800"
al="$al hp9000 hp9000s300 hp9000s400 hp9000s500"
al="$al hp9000s700 hp9000s800 hp9k8 hppa hpux"
al="$al i186 i286 i386 i486 i8086"
al="$al i80960 i860 iAPX286 ibm ibm032 ibmrt interdata is68k"
al="$al ksr1 linux luna luna88k m68k m88100 m88k"
al="$al mc300 mc500 mc68000 mc68010 mc68020 mc68030"
al="$al mc68040 mc68060 mc68k mc68k32 mc700"
al="$al mc88000 mc88100 merlin mert mips mvs n16"
al="$al ncl_el ncl_mr"
al="$al news1500 news1700 news1800 news1900 news3700"
al="$al news700 news800 news900 ns16000 ns32000"
al="$al ns32016 ns32332 ns32k nsc32000 os osf"
al="$al parisc pc532 pdp11 plexus posix pyr"
al="$al riscix riscos scs sequent sgi sinix sony sony_news"
al="$al sonyrisc sparc sparclite spectrum stardent stratos"
al="$al sun sun3 sun386 svr4 sysV68 sysV88"
al="$al titan tower tower32 tower32_200 tower32_600 tower32_700"
al="$al tower32_800 tower32_850 tss u370 u3b u3b2 u3b20 u3b200"
al="$al u3b20d u3b5 ultrix unix unixpc unos vax venix vms"
al="$al xenix z8000"

: No trailing extension on UNIX executables
_exe='' 
: Extra object files, if any, needed on this platform.
archobjs=''
gccversion=''
: change the next line if compiling for Xenix/286 on Xenix/386
xlibpth='/usr/lib/386 /lib/386'

: Possible local library directories to search.
loclibpth="/usr/local/lib /opt/local/lib /usr/gnu/lib"
loclibpth="$loclibpth /opt/gnu/lib /usr/GNU/lib /opt/GNU/lib"

: general looking path for locating libraries
glibpth="/shlib /usr/shlib /lib/pa1.1 /usr/lib/large"
glibpth="$glibpth /lib /usr/lib $xlibpth"
glibpth="$glibpth /lib/large /usr/lib/small /lib/small"
glibpth="$glibpth /usr/ccs/lib /usr/ucblib /usr/local/lib"

: Private path used by Configure to find libraries.  Its value
: is prepended to libpth. This variable takes care of special
: machines, like the mips.  Usually, it should be empty.
plibpth=''

large=''
: full support for void wanted by default
defvoidused=15

: Possible local include directories to search.
: Set locincpth to "" in a hint file to defeat local include searches.
locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
locincpth="$locincpth /opt/gnu/include /usr/GNU/include /opt/GNU/include"
locincpth="$locincpth /usr/kerberos/include"
:
: no include file wanted by default
inclwanted=''

: default library list
libswanted=''
defvoidused=15
libswanted='nsl socket m c crypt bind resolv ld dl tcl intl'

: Find the basic shell for Bourne shell scripts
case "$sh" in
'')
	case "$SYSTYPE" in
	*bsd*|sys5*) xxx="/$SYSTYPE/bin/sh";;
	*) xxx='/bin/sh';;
	esac
	if test -f "$xxx"; then
		sh="$xxx"
	else
		: Build up a list and do a single loop so we can 'break' out.
		pth=`echo $PATH | sed -e "s/$p_/ /g"`
		for xxx in sh bash ksh pdksh ash; do
			for p in $pth; do
				try="$try ${p}/${xxx}"
			done
		done
		for xxx in $try; do
			if test -f "$xxx"; then
				sh="$xxx";
				break
			elif test -f "$xxx.exe"; then
				sh="$xxx";
				break
			fi
		done
	fi
	;;
esac

case "$sh" in
'')	cat <<EOM >&2
$me:  Fatal Error:  I can't find a Bourne Shell anywhere.  

Usually it's in /bin/sh.  How did you even get this far?
Please contact me (Nveid) at devteam@cobramush.org and 
we'll try to straighten this all out.
EOM
	exit 1
	;;
esac

: see if sh knows # comments
if `$sh -c '#' >/dev/null 2>&1`; then
	shsharp=true
	spitshell=cat
	xcat=/bin/cat
	test -f $xcat || xcat=/usr/bin/cat
	echo "#!$xcat" >try
	$eunicefix try
	chmod +x try
	./try > today
	if test -s today; then
		sharpbang='#!'
	else
		echo "#! $xcat" > try
		$eunicefix try
		chmod +x try
		./try > today
		if test -s today; then
			sharpbang='#! '
		else
			sharpbang=': use '
		fi
	fi
else
	echo " "
	echo "Your $sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	cd ..
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	cd UU
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f try today

: figure out how to guarantee sh startup
case "$startsh" in
'') startsh=${sharpbang}${sh} ;;
*)
esac
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
$eunicefix try
if ./try; then
	: echo "Yup, it does."
else
	echo "Hmm... '$startsh' does not guarantee sh startup..."
	echo "You may have to fix up the shell scripts to make sure $sh runs them."
fi
rm -f try

: produce awk script to parse command line options
cat >options.awk <<'EOF'
BEGIN {
	optstr = "dD:eEf:hKOrsSU:V";	# getopt-style specification

	len = length(optstr);
	for (i = 1; i <= len; i++) {
		c = substr(optstr, i, 1);
		if (i < len) a = substr(optstr, i + 1, 1); else a = "";
		if (a == ":") {
			arg[c] = 1;
			i++;
		}
		opt[c] = 1;
	}
}
{
	expect = 0;
	str = $0;
	if (substr(str, 1, 1) != "-") {
		printf("'%s'\n", str);
		next;
	}
	len = length($0);
	for (i = 2; i <= len; i++) {
		c = substr(str, i, 1);
		if (!opt[c]) {
			printf("-%s\n", substr(str, i));
			next;
		}
		printf("-%s\n", c);
		if (arg[c]) {
			if (i < len)
				printf("'%s'\n", substr(str, i + 1));
			else
				expect = 1;
			next;
		}
	}
}
END {
	if (expect)
		print "?";
}
EOF

: process the command line options
set X `for arg in "$@"; do echo "X$arg"; done |
	sed -e s/X// | awk -f options.awk`
eval "set $*"
shift
rm -f options.awk

: set up default values
fastread=''
reuseval=false
config_sh=''
alldone=''
error=''
silent=''
extractsh=''
override=''
knowitall=''
rm -f optdef.sh
cat >optdef.sh <<EOS
$startsh
EOS


: option parsing
while test $# -gt 0; do
	case "$1" in
	-d) shift; fastread=yes;;
	-e) shift; alldone=cont;;
	-f)
		shift
		cd ..
		if test -r "$1"; then
			config_sh="$1"
		else
			echo "$me: cannot read config file $1." >&2
			error=true
		fi
		cd UU
		shift;;
	-h) shift; error=true;;
	-r) shift; reuseval=true;;
	-s) shift; silent=true; realsilent=true;;
	-E) shift; alldone=exit;;
	-K) shift; knowitall=true;;
	-O) shift; override=true;;
	-S) shift; silent=true; extractsh=true;;
	-D)
		shift
		case "$1" in
		*=)
			echo "$me: use '-U symbol=', not '-D symbol='." >&2
			echo "$me: ignoring -D $1" >&2
			;;
		*=*) echo "$1" | \
				sed -e "s/'/'\"'\"'/g" -e "s/=\(.*\)/='\1'/" >> optdef.sh;;
		*) echo "$1='define'" >> optdef.sh;;
		esac
		shift
		;;
	-U)
		shift
		case "$1" in
		*=) echo "$1" >> optdef.sh;;
		*=*)
			echo "$me: use '-D symbol=val', not '-U symbol=val'." >&2
			echo "$me: ignoring -U $1" >&2
			;;
		*) echo "$1='undef'" >> optdef.sh;;
		esac
		shift
		;;
	-V) echo "$me generated by metaconfig 3.0 PL70." >&2
		exit 0;;
	--) break;;
	-*) echo "$me: unknown option $1" >&2; shift; error=true;;
	*) break;;
	esac
done

case "$error" in
true)
	cat >&2 <<EOM
Usage: $me [-dehrsEKOSV] [-f config.sh] [-D symbol] [-D symbol=value]
                 [-U symbol] [-U symbol=]
  -d : use defaults for all answers.
  -e : go on without questioning past the production of config.sh.
  -f : specify an alternate default configuration file.
  -h : print this help message and exit (with an error status).
  -r : reuse C symbols value if possible (skips costly nm extraction).
  -s : silent mode, only echoes questions and essential information.
  -D : define symbol to have some value:
         -D symbol         symbol gets the value 'define'
         -D symbol=value   symbol gets the value 'value'
  -E : stop at the end of questions, after having produced config.sh.
  -K : do not use unless you know what you are doing.
  -O : let -D and -U override definitions from loaded configuration file.
  -S : perform variable substitutions on all .SH files (can mix with -f)
  -U : undefine symbol:
         -U symbol    symbol gets the value 'undef'
         -U symbol=   symbol gets completely empty
  -V : print version number and exit (with a zero status).
EOM
	exit 1
	;;
esac

: Sanity checks
case "$fastread$alldone" in
yescont|yesexit) ;;
*)
	if test ! -t 0; then
		echo "Say 'sh Configure', not 'sh <Configure'"
		exit 1
	fi
	;;
esac

exec 4>&1
case "$silent" in
true) exec 1>/dev/null;;
esac

: run the defines and the undefines, if any, but leave the file out there...
touch optdef.sh
. ./optdef.sh

: set package name
package=cobramush

: Some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
	contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
else
	contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
	echo " "
	echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
	cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
	echo "...using -n."
	n='-n'
	c=''
else
	cat <<'EOM'
...using \c
EOM
	n=''
	c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: compute the number of columns on the terminal for proper question formatting
case "$COLUMNS" in
'') COLUMNS='80';;
esac

: set up the echo used in my read
myecho="case \"\$xxxm\" in
'') echo $n \"\$rp $c\" >&4;;
*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*)
		if test \`echo \"\$rp [\$xxxm]  \" | wc -c\` -ge $COLUMNS; then
			echo \"\$rp\" >&4
			echo $n \"[\$xxxm] $c\" >&4
		else
			echo $n \"\$rp [\$xxxm] $c\" >&4
		fi
		;;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
$startsh
xxxm=\$dflt
$myecho
ans='!'
case "\$fastread" in
yes) case "\$dflt" in
	'') ;;
	*) ans='';
		case "\$silent-\$rp" in
		true-) ;;
		*) echo " " >&4;;
		esac;;
	esac;;
*) case "\$silent" in
	true) case "\$rp" in
		'') ans='';;
		esac;;
	esac;;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval "ans=\\"\$answ\\"" && aok=y
	case  "\$answ" in
	"!")
		sh 1>&4
		echo " "
		$myecho
		;;
	!*)
		set x \`expr "X\$ans" : "X!\(.*\)\$"\`
		shift
		sh 1>&4 -c "\$*"
		echo " "
		$myecho
		;;
	"\$ans")
		case "\$ans" in
		\\&*)
			set x \`expr "X\$ans" : "X&\(.*\)\$"\`
			shift
			case "\$1" in
			-d)
				fastread=yes
				echo "(OK, I'll run with -d after this question.)" >&4
				;;
			-*)
				echo "*** Sorry, \$1 not supported yet." >&4
				;;
			esac
			$myecho
			ans=!
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '\012' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
	case "\$ans\$xxxm\$nostick" in
	'')
		ans=!
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: Find the path to the source tree
case "$src" in
'') src=`echo $0 | sed -e 's%/[^/][^/]*$%%'`;;
esac
case "$src" in
'')
	src=.
	rsrc=..
	;;
/*) rsrc="$src/..";;
*) rsrc="../$src";;
esac
if test -f $rsrc/Configure && \
	$contains "^package=$package" $rsrc/Configure >/dev/null 2>&1
then
   : found it, so we are ok.
else
	rsrc=''
	for src in . .. ../.. ../../.. ../../../..; do
		if test -f ../$src/Configure && \
			$contains "^package=$package" ../$src/Configure >/dev/null 2>&1
		then
			rsrc=../$src
			break
		fi
	done
fi
case "$rsrc" in
'')
	echo " "
	dflt=
	rp="Directory where sources for $package are located?"
	. ./myread
	src="$ans"
	rsrc="$src"
	if test -f $rsrc/Configure && \
		$contains "^package=$package" $rsrc/Configure >/dev/null 2>&1
	then
		echo "Ok, I've found them under $src"
	else
		echo "Sorry, I can't seem to be able to locate $package sources." >&4
		exit 1
	fi
	;;
../.) ;;
*)
	echo " "
	echo "Sources for $package found in $src" >&4
	;;
esac

: script used to extract .SH files with variable substitutions
cat >extract <<'EOS'
CONFIG=true
echo "Doing variable substitutions on .SH files..."
if test -f $src/MANIFEST; then
	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
else
	echo "(Looking for .SH files under the source directory.)"
	set x `(cd $src; find . -name "*.SH" -print)`
fi
shift
case $# in
0) set x `(cd $src; echo *.SH)`; shift;;
esac
if test ! -f $src/$1; then
	shift
fi
mkdir_p='
name=$1;
create="";
while test $name; do
	if test ! -d "$name"; then
		create="$name $create";
		name=`echo $name | sed -e "s|^[^/]*$||"`;
		name=`echo $name | sed -e "s|\(.*\)/.*|\1|"`;
	else
		name="";
	fi;
done;
for file in $create; do
	mkdir $file;
done
'
for file in $*; do
	case "$src" in
	".")
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			(cd $dir && . ./$file)
			;;
		*)
			. ./$file
			;;
		esac
		;;
	*)
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			(set x $dir; shift; eval $mkdir_p)
			sh <$src/$dir/$file
			;;
		*)
			sh <$src/$file
			;;
		esac
		;;
	esac
done
if test -f $src/config_h.SH; then
	if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. $src/config_h.SH
	fi
fi
EOS

: extract files and exit if asked to do so
case "$extractsh" in
true)
	case "$realsilent" in
	true) ;;
	*) exec 1>&4;;
	esac
	case "$config_sh" in
	'') config_sh='config.sh'; config="$rsrc/config.sh";;
	/*) config="$config_sh";;
	*) config="$rsrc/$config_sh";;
	esac
	echo " "
	echo "Fetching answers from $config_sh..."
	. $config
	test "$override" && . ./optdef.sh
	echo " "
	cd ..
	. UU/extract
	rm -rf UU
	echo "Done."
	exit 0
	;;
esac

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package."

trap 'echo " "; test -d ../UU && rm -rf X $rmlist; exit 1' 1 2 3 15

: Now test for existence of everything in MANIFEST
echo " "
if test -f $rsrc/MANIFEST; then
	echo "First let's make sure your kit is complete.  Checking..." >&4
	awk '$1 !~ /PACK[A-Z]+/ {print $1}' $rsrc/MANIFEST | split -50
	rm -f missing
	tmppwd=`pwd`
	for filelist in x??; do
		(cd $rsrc; ls `cat $tmppwd/$filelist` >/dev/null 2>>$tmppwd/missing)
	done
	if test -s missing; then
		cat missing >&4
		cat >&4 <<'EOM'

THIS PACKAGE SEEMS TO BE INCOMPLETE.

You have the option of continuing the configuration process, despite the
distinct possibility that your kit is damaged, by typing 'y'es.  If you
do, don't blame me if something goes wrong.  I advise you to type 'n'o
and contact the author (devteam@cobramush.org).

EOM
		echo $n "Continue? [n] $c" >&4
		read ans
		case "$ans" in
		y*)
			echo "Continuing..." >&4
			rm -f missing
			;;
		*)
			echo "ABORTING..." >&4
			kill $$
			;;
		esac
	else
		echo "Looks good..."
	fi
else
	echo "There is no MANIFEST file.  I hope your kit is complete !"
fi
rm -f missing x??

: create .config dir to save info across Configure sessions
test -d ../.config || mkdir ../.config
cat >../.config/README <<EOF
This directory created by Configure to save information that should
persist across sessions for $package.

You may safely delete it if you wish.
EOF

: general instructions
needman=true
firsttime=true
user=`(logname) 2>/dev/null`
case "$user" in
'') user=`whoami 2>&1`;;
esac
if $contains "^$user\$" ../.config/instruct >/dev/null 2>&1; then
	firsttime=false
	echo " "
	rp='Would you like to see the instructions?'
	dflt=n
	. ./myread
	case "$ans" in
	[yY]*) ;;
	*) needman=false;;
	esac
fi
if $needman; then
	cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the cobramush package should be installed. If you get
stuck on a question, you may use a ! shell escape to start a subshell or
execute a command.  Many of the questions will have default answers in square
brackets; typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
	rp=''
	dflt='Type carriage return to continue'
	. ./myread
	cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file). Type 'Configure -h' for a list of options.
You may also start interactively and then answer '& -d' at any prompt to turn
on the non-interactive behaviour for the remaining of the execution.

EOH
	. ./myread
	cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  If you can't run Configure for some reason,
you'll have to generate a config.sh file by hand.  Whatever problems you
have, let me (devteam@cobramush.org) know how I blew it.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
	dflt='Type carriage return to continue'
	. ./myread
	case "$firsttime" in
	true) echo $user >>../.config/instruct;;
	esac
fi

: find out where common programs are
echo " "
echo "Locating common programs..." >&4
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
	case "\$thing" in
	.)
	if test -d \$dir/\$thing; then
		echo \$dir
		exit 0
	fi
	;;
	*)
	for thisthing in \$dir/\$thing; do
		: just loop through to pick last item
	done
	if test -f \$thisthing; then
		echo \$thisthing
		exit 0
	elif test -f \$dir/\$thing.exe; then
		: on Eunice apparently
		echo \$dir/\$thing
		exit 0
	fi
	;;
	esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
awk
cat
chmod
comm
cp
echo
expr
grep
make
mkdir
rm
sed
sort
touch
tr
uniq
"
trylist="
Mcc
cpp
date
line
ln
mail
perl
rmail
sendmail
smail
test
uname
uptime
"
pth=`echo $PATH | sed -e "s/$p_/ /g"`
pth="$pth /lib /usr/lib"
for file in $loclist; do
	eval xxx=\$$file
	case "$xxx" in
	/*|?:[\\/]*)
		if test -f "$xxx"; then
			: ok
		else
			echo "WARNING: no $xxx -- ignoring your setting for $file." >&4
			xxx=`./loc $file $file $pth`
		fi
		;;
	'') xxx=`./loc $file $file $pth`;;
	*) xxx=`./loc $xxx $xxx $pth`;;
	esac
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't know where '$file' is, and my life depends on it." >&4
		echo "Go find a public domain implementation or fix your PATH setting!" >&4
		exit 1
		;;
	esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
say=offhand
for file in $trylist; do
	eval xxx=\$$file
	case "$xxx" in
	/*|?:[\\/]*)
		if test -f "$xxx"; then
			: ok
		else
			echo "WARNING: no $xxx -- ignoring your setting for $file." >&4
			xxx=`./loc $file $file $pth`
		fi
		;;
	'') xxx=`./loc $file $file $pth`;;
	*) xxx=`./loc $xxx $xxx $pth`;;
	esac
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't see $file out there, $say."
		say=either
		;;
	esac
done
case "$egrep" in
egrep)
	echo "Substituting grep for egrep."
	egrep=$grep
	;;
esac
case "$ln" in
ln)
	echo "Substituting cp for ln."
	ln=$cp
	;;
esac
case "$test" in
test)
	echo "Hopefully test is built into your sh."
	;;
*)
	if `sh -c "PATH= test true" >/dev/null 2>&1`; then
		echo "Using the test built into your sh."
		test=test
		_test=test
	fi
	;;
esac
case "$echo" in
echo)
	echo "Hopefully echo is built into your sh."
	;;
'') ;;
*)
	echo " "
echo "Checking compatibility between $echo and builtin echo (if any)..." >&4
	$echo $n "hi there$c" >foo1
	echo $n "hi there$c" >foo2
	if cmp foo1 foo2 >/dev/null 2>&1; then
		echo "They are compatible.  In fact, they may be identical."
	else
		case "$n" in
		'-n') n='' c='\c';;
		*) n='-n' c='';;
		esac
		cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use $echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use '$n$c' to suppress newlines now.  Life is ridiculous.

FOO
		$echo $n "The star should be here-->$c"
		$echo "*"
	fi
	$rm -f foo1 foo2
	;;
esac

: determine whether symbolic links are supported
echo " "
$touch blurfl
if $ln -s blurfl sym > /dev/null 2>&1 ; then
	echo "Symbolic links are supported." >&4
	lns="$ln -s"
else
	echo "Symbolic links are NOT supported." >&4
	lns="$ln"
fi
$rm -f blurfl sym

: see whether [:lower:] and [:upper:] are supported character classes
echo " "
up='[A-Z]'
low='[a-z]'
case "`echo AbyZ | $tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
ABYZ)
	echo "Good, your tr supports [:lower:] and [:upper:] to convert case." >&4
	up='[:upper:]'
	low='[:lower:]'
	;;
*)
	echo "Your tr only supports [a-z] and [A-Z] to convert case." >&4
	;;
esac
: set up the translation script tr, must be called with ./tr of course
cat >tr <<EOSC
$startsh
case "\$1\$2" in
'[A-Z][a-z]') exec $tr '$up' '$low';;
'[a-z][A-Z]') exec $tr '$low' '$up';;
esac
exec $tr "\$@"
EOSC
chmod +x tr
$eunicefix tr

: Try to determine whether config.sh was made on this system
case "$config_sh" in
'')
myuname=`( ($uname -a) 2>/dev/null || hostname) 2>&1`
myuname=`echo $myuname | $sed -e 's/^[^=]*=//' -e 's/\///g' | \
	./tr '[A-Z]' '[a-z]' | tr '\012' ' '`
newmyuname="$myuname"
dflt=n
case "$knowitall" in
'')
	if test -f ../config.sh; then
		if $contains myuname= ../config.sh >/dev/null 2>&1; then
			eval "`grep myuname= ../config.sh`"
		fi
		if test "X$myuname" = "X$newmyuname"; then
			dflt=y
		fi
	fi
	;;
*) dflt=y;;
esac

: Get old answers from old config file if Configure was run on the
: same system, otherwise use the hints.
hint=default
cd ..
if test -f config.sh; then
	echo " "
	rp="I see a config.sh file.  Shall I use it to set the defaults?"
	. UU/myread
	case "$ans" in
	n*|N*) echo "OK, I'll ignore it."; mv config.sh config.sh.old;;
	*)  echo "Fetching default answers from your old config.sh file..." >&4
		tmp_n="$n"
		tmp_c="$c"
		tmp_sh="$sh"
		. ./config.sh
		cp config.sh UU
		n="$tmp_n"
		c="$tmp_c"
		: Older versions did not always set $sh.  Catch re-use of such
		: an old config.sh.
		case "$sh" in
		'') sh="$tmp_sh" ;;
		esac
		hint=previous
		;;
	esac
fi
if test ! -f config.sh; then
	$cat <<EOM

First time through, eh?  I have some defaults handy for the following systems:

EOM
	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
	dflt=''
	: Half the following guesses are probably wrong... If you have better
	: tests or hints, please send them to devteam@cobramush.org
	: The metaconfig authors would also appreciate a copy...
	$test -f /irix && osname=irix
	$test -f /xenix && osname=sco_xenix
	$test -f /dynix && osname=dynix
	$test -f /dnix && osname=dnix
	$test -f /lynx.os && osname=lynxos
	$test -f /unicos && osname=unicos && osvers=`$uname -r`
	$test -f /unicosmk.ar && osname=unicosmk && osvers=`$uname -r`
	$test -f /bin/mips && /bin/mips && osname=mips
	$test -d /NextApps && set X `hostinfo | grep 'NeXT Mach.*:' | \
		$sed -e 's/://' -e 's/\./_/'` && osname=next && osvers=$4
	$test -d /usr/apollo/bin && osname=apollo
	$test -f /etc/saf/_sactab && osname=svr4
	$test -d /usr/include/minix && osname=minix
	if $test -d /MachTen; then
		osname=machten
		if $test -x /sbin/version; then
			osvers=`/sbin/version | $awk '{print $2}' |
			$sed -e 's/[A-Za-z]$//'`
		elif $test -x /usr/etc/version; then
			osvers=`/usr/etc/version | $awk '{print $2}' |
			$sed -e 's/[A-Za-z]$//'`
		else
			osvers="$2.$3"
		fi
	fi
	if $test -f $uname; then
		set X $myuname
		shift

		case "$5" in
		fps*) osname=fps ;;
		mips*)
			case "$4" in
			umips) osname=umips ;;
			*) osname=mips ;;
			esac;;
		[23]100) osname=mips ;;
		next*) osname=next ;;
		news*) osname=news ;;
		i386*)
			if $test -f /etc/kconfig; then
				osname=isc
				if test "$lns" = "ln -s"; then
					osvers=4
				elif $contains _SYSV3 /usr/include/stdio.h > /dev/null 2>&1 ; then
					osvers=3
				elif $contains _POSIX_SOURCE /usr/include/stdio.h > /dev/null 2>&1 ; then
					osvers=2
				fi
			fi
			;;
		esac

		case "$1" in
		aix) osname=aix
			tmp=`( (oslevel) 2>/dev/null || echo "not found") 2>&1`
			case "$tmp" in
			'not found') osvers="$4"."$3" ;;
			'<3240'|'<>3240') osvers=3.2.0 ;;
			'=3240'|'>3240'|'<3250'|'<>3250') osvers=3.2.4 ;;
			'=3250'|'>3250') osvers=3.2.5 ;;
			*) osvers=$tmp;;
			esac
			;;
		*dc.osx) osname=dcosx
			osvers="$3"
			;;
		dnix) osname=dnix
			osvers="$3"
			;;
		domainos) osname=apollo
			osvers="$3"
			;;
		dgux) osname=dgux
			osvers="$3"
			;;
		dynixptx*) osname=dynixptx
			osvers="$3"
			;;
		freebsd) osname=freebsd
			osvers="$3" ;;
		genix) osname=genix ;;
		hp*) osname=hpux
			case "$3" in
			*.08.*) osvers=9 ;;
			*.09.*) osvers=9 ;;
			*.10.*) osvers=10 ;;
			*)	osvers="$3" ;;
			esac
			;;
		irix*) osname=irix
			case "$3" in
			4*) osvers=4 ;;
			5*) osvers=5 ;;
			6*) osvers=6 ;;
			*)	osvers="$3" ;;
			esac
			;;
		linux) osname=linux
			case "$3" in
			1*) osvers=1 ;;
			*)	osvers="$3" ;;
			esac
			;;
		netbsd*) osname=netbsd
			osvers="$3"
			;;
		bsd386) osname=bsd386
			osvers=`$uname -r`
			;;
		next*) osname=next ;;
		solaris) osname=solaris
			case "$3" in
			5*) osvers=`echo $3 | $sed 's/^5/2/g'` ;;
			*)	osvers="$3" ;;
			esac
			;;
		sunos) osname=sunos
			case "$3" in
			5*) osname=solaris
				osvers=`echo $3 | $sed 's/^5/2/g'` ;;
			*)	osvers="$3" ;;
			esac
			;;
		titanos) osname=titanos
			case "$3" in
			1*) osvers=1 ;;
			2*) osvers=2 ;;
			3*) osvers=3 ;;
			4*) osvers=4 ;;
			*)	osvers="$3" ;;
			esac
			;;
		ultrix) osname=ultrix
			osvers="$3"
			;;
		osf1|mls+)	case "$5" in
				alpha)
					osname=dec_osf
					osvers=`echo "$3" | sed 's/^[vt]//'`
					;;
			hp*)	osname=hp_osf1	;;
			mips)	osname=mips_osf1 ;;
			esac
			;;
		uts) osname=uts
			osvers="$3"
			;;
		qnx) osname=qnx
			osvers="$4"
			;;
                mingw32*) osname=mingw32
                       osvers="$3"
                       ;;
		$2) case "$osname" in
			*isc*) ;;
			*freebsd*) ;;
			svr*)
				: svr4.x or possibly later
				case "svr$3" in	
				${osname}*)
					osname=svr$3
					osvers=$4
					;;
				esac
				case "$osname" in
				svr4.0)
					: Check for ESIX
					if test -f /stand/boot ; then
						eval `grep '^INITPROG=[a-z/0-9]*$' /stand/boot`
						if test -n "$INITPROG" -a -f "$INITPROG"; then
			isesix=`strings -a $INITPROG|grep 'ESIX SYSTEM V/386 Release 4.0'`
							if test -n "$isesix"; then
								osname=esix4
							fi
						fi
					fi
					;;
				esac
				;;
			*)	if test -f /etc/systemid; then
					osname=sco
					set `echo $3 | $sed 's/\./ /g'` $4
					if $test -f sco_$1_$2_$3.sh; then
						osvers=$1.$2.$3
					elif $test -f sco_$1_$2.sh; then
						osvers=$1.$2
					elif $test -f sco_$1.sh; then
						osvers=$1
					fi
				else
					case "$osname" in
					'') : Still unknown.  Probably a generic Sys V.
						osname="sysv"
						osvers="$3"
						;;
					esac
				fi
				;;
			esac
			;;
		*)	case "$osname" in
			'') : Still unknown.  Probably a generic BSD.
				osname="$1"
				osvers="$3"
				;;
			esac
			;;
		esac
	else
		if test -f /vmunix -a -f $src/hints/news_os.sh; then
			(what /vmunix | UU/tr '[A-Z]' '[a-z]') > UU/kernel.what 2>&1
			if $contains news-os UU/kernel.what >/dev/null 2>&1; then
				osname=news_os
			fi
			$rm -f UU/kernel.what
		elif test -d c:/.; then
			: Check for cygwin32 emulation
			case "x$OS" in
			xWindows_*)
				set X $myuname
				osname=win32
				osvers="$3"
				;;
			x*)
				set X $myuname
				osname=os2
				osvers="$5"
				;;
			esac
		fi
	fi
	case "x$osname" in
	xcygwin32*)
		osname=win32
		;;
	esac
	
	: Now look for a hint file osname_osvers, unless one has been
	: specified already.
	case "$hintfile" in
	''|' ')
		file=`echo "${osname}_${osvers}" | $sed -e 's@\.@_@g' -e 's@_$@@'`
		: Also try without trailing minor version numbers.
		xfile=`echo $file | $sed -e 's@_[^_]*$@@'`
		xxfile=`echo $xfile | $sed -e 's@_[^_]*$@@'`
		xxxfile=`echo $xxfile | $sed -e 's@_[^_]*$@@'`
		xxxxfile=`echo $xxxfile | $sed -e 's@_[^_]*$@@'`
		case "$file" in
		'') dflt=none ;;
		*)  case "$osvers" in
			'') dflt=$file
				;;
			*)  if $test -f $src/hints/$file.sh ; then
					dflt=$file
				elif $test -f $src/hints/$xfile.sh ; then
					dflt=$xfile
				elif $test -f $src/hints/$xxfile.sh ; then
					dflt=$xxfile
				elif $test -f $src/hints/$xxxfile.sh ; then
					dflt=$xxxfile
				elif $test -f $src/hints/$xxxxfile.sh ; then
					dflt=$xxxxfile
				elif $test -f "$src/hints/${osname}.sh" ; then
					dflt="${osname}"
				else
					dflt=none
				fi
				;;
			esac
			;;
		esac
		;;
	*)
		dflt=`echo $hintfile | $sed 's/\.sh$//'`
		;;
	esac

	$cat <<EOM

You may give one or more space-separated answers, or "none" if appropriate.
If your OS version has no hints, DO NOT give a wrong version -- say "none".

EOM
	rp="Which of these apply, if any?"
	. UU/myread
	tans=$ans
	for file in $tans; do
		if $test -f $src/hints/$file.sh; then
			. $src/hints/$file.sh
			$cat $src/hints/$file.sh >> UU/config.sh
		elif $test X$tans = X -o X$tans = Xnone ; then
			: nothing
		else
			: Give one chance to correct a possible typo.
			echo "$file.sh does not exist"
			dflt=$file
			rp="hint to use instead?"
			. UU/myread
			for file in $ans; do
				if $test -f "$src/hints/$file.sh"; then
					. $src/hints/$file.sh
					$cat $src/hints/$file.sh >> UU/config.sh
				elif $test X$ans = X -o X$ans = Xnone ; then
					: nothing
				else
					echo "$file.sh does not exist -- ignored."
				fi
			done
		fi
	done

	hint=recommended
	: Remember our hint file for later.
	if $test -f "$src/hints/$file.sh" ; then
		hintfile="$file"
	else
		hintfile=''
	fi
fi
cd UU
;;
*)
	echo " "
	echo "Fetching default answers from $config_sh..." >&4
	tmp_n="$n"
	tmp_c="$c"
	cd ..
	cp $config_sh config.sh 2>/dev/null
	chmod +w config.sh
	. ./config.sh
	cd UU
	cp ../config.sh .
	n="$tmp_n"
	c="$tmp_c"
	hint=previous
	;;
esac
test "$override" && . ./optdef.sh
myuname="$newmyuname"

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

cat << EOM

Configure uses the operating system name and version to set some defaults.
The default value is probably right if the name rings a bell. Otherwise,
since spelling matters for me, either accept the default or answer "none"
to leave it blank.

EOM
case "$osname" in
	''|' ')
		case "$hintfile" in
		''|' '|none) dflt=none ;;
		*)  dflt=`echo $hintfile | $sed -e 's/\.sh$//' -e 's/_.*$//'` ;;
		esac
		;;
	*) dflt="$osname" ;;
esac
rp="Operating system name?"
. ./myread
case "$ans" in
none)  osname='' ;;
*) osname=`echo "$ans" | $sed -e 's/[ 	][	]*/_/g' | ./tr '[A-Z]' '[a-z]'`;;
esac
: who configured the system
cf_time=`$date 2>&1`
cf_by=`(logname) 2>/dev/null`
case "$cf_by" in
"")
	cf_by=`(whoami) 2>/dev/null`
	case "$cf_by" in
	"") cf_by=unknown ;;
	esac ;;
esac

: determine where manual pages are on this system
echo " "
case "$sysman" in
'') 
	syspath='/usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1'
	syspath="$syspath /usr/man/u_man/man1 /usr/share/man/man1"
	syspath="$syspath /usr/catman/u_man/man1 /usr/man/l_man/man1"
	syspath="$syspath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
	syspath="$syspath /usr/man/man.L /local/man/man1 /usr/local/man/man1"
	sysman=`./loc . /usr/man/man1 $syspath`
	;;
esac
if $test -d "$sysman"; then
	echo "System manual is in $sysman." >&4
else
	echo "Could not find manual pages in source form." >&4
fi

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
echo exit 1 >bsd
echo exit 1 >usg
echo exit 1 >v7
echo exit 1 >osf1
echo exit 1 >eunice
echo exit 1 >xenix
echo exit 1 >venix
d_bsd="$undef"
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test -f /osf_boot || $contains 'OSF/1' /usr/include/ctype.h >/dev/null 2>&1
then
	echo "Looks kind of like an OSF/1 system, but we'll see..."
	echo exit 0 >osf1
elif test `echo abc | tr a-z A-Z` = Abc ; then
	xxx=`./loc addbib blurfl $pth`
	if $test -f $xxx; then
	echo "Looks kind of like a USG system with BSD features, but we'll see..."
		echo exit 0 >bsd
		echo exit 0 >usg
	else
		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
			echo "Looks kind of like an extended USG system, but we'll see..."
		else
			echo "Looks kind of like a USG system, but we'll see..."
		fi
		echo exit 0 >usg
	fi
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
	echo exit 0 >bsd
else
	echo "Looks kind of like a Version 7 system, but we'll see..."
	echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
	$cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
	echo exit 0 >eunice
	d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
	echo " "
	echo "Congratulations.  You aren't running Eunice."
	d_eunice="$undef"
	;;
esac
if test -f /xenix; then
	echo "Actually, this looks more like a XENIX system..."
	echo exit 0 >xenix
	d_xenix="$define"
else
	echo " "
	echo "It's not Xenix..."
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
	echo "Actually, this looks more like a VENIX system..."
	echo exit 0 >venix
else
	echo " "
	if ./xenix; then
		: null
	else
		echo "Nor is it Venix..."
	fi
fi
chmod +x bsd usg v7 osf1 eunice xenix venix
$eunicefix bsd usg v7 osf1 eunice xenix venix
$rm -f foo

: see if we need a special compiler
echo " "
if ./usg; then
	case "$cc" in
	'') case "$Mcc" in
		/*) dflt='Mcc';;
		*) case "$large" in
			-M*) dflt='cc';;
			*)	if $contains '\-M' $sysman/cc.1 >/dev/null 2>&1 ; then
					if $contains '\-M' $sysman/cpp.1 >/dev/null 2>&1; then
						dflt='cc'
					else
						dflt='cc -M'
					fi
				else
					dflt='cc'
				fi;;
			esac;;
		esac;;
	*)  dflt="$cc";;
	esac
	$cat <<'EOM'
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the "Mcc"
command may be used to force these to be resolved.  On other systems a "cc -M"
command is required.  (Note that the -M flag on other systems indicates a
memory model to use!) If you have the Gnu C compiler, you might wish to use
that instead.

EOM
	rp="What command will force resolution on this system?"
	. ./myread
	cc="$ans"
else
	case "$cc" in
	'') dflt=cc;;
	*) dflt="$cc";;
	esac
	rp="Use which C compiler?"
	. ./myread
	cc="$ans"
fi
echo " "
echo "Checking for GNU cc in disguise and/or its version number..." >&4
$cat >gccvers.c <<EOM
#include <stdio.h>
int main() {
#ifdef __GNUC__
#ifdef __VERSION__
	printf("%s\n", __VERSION__);
#else
	printf("%s\n", "1");
#endif
#endif
	exit(0);
}
EOM
if $cc -o gccvers gccvers.c >/dev/null 2>&1; then
	gccversion=`./gccvers`
	case "$gccversion" in
	'') echo "You are not using GNU cc." ;;
	*)  echo "You are using GNU cc $gccversion." ;;
	esac
else
	echo " "
	echo "*** WHOA THERE!!! ***" >&4
	echo "    Your C compiler \"$cc\" doesn't seem to be working!" >&4
	case "$knowitall" in
	'')
	echo "    You'd better start hunting for one and let me know about it." >&4
		exit 1
		;;
	esac
fi
$rm -f gccvers*
case "$gccversion" in
1*) cpp=`./loc gcc-cpp $cpp $pth` ;;
esac

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) Shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines?"
. ./myread
case "$ans" in
	y*) d_portable="$define"
	;;
	*)  d_portable="$undef" ;;
esac

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
	echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
	;;
 ~*)
	if $test -f /bin/csh; then
		/bin/csh -f -c "glob \$1"
		failed=\$?
		echo ""
		exit \$failed
	else
		name=\`$expr x\$1 : '..\([^/]*\)'\`
		dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
		if $test ! -d "\$dir"; then
			me=\`basename \$0\`
			echo "\$me: can't locate home directory for: \$name" >&2
			exit 1
		fi
		case "\$1" in
		*/*)
			echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
			;;
		*)
			echo \$dir
			;;
		esac
	fi
	;;
*)
	echo \$1
	;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: now set up to get a file name
cat <<EOS >getfile
$startsh
EOS
cat <<'EOSC' >>getfile
tilde=''
fullpath=''
already=''
skip=''
none_ok=''
exp_file=''
nopath_ok=''
orig_rp="$rp"
orig_dflt="$dflt"

case "$fn" in
*\(*)
	expr $fn : '.*(\(.*\)).*' | tr ',' '\012' >getfile.ok
	fn=`echo $fn | sed 's/(.*)//'`
	;;
esac

case "$fn" in
*:*)
	loc_file=`expr $fn : '.*:\(.*\)'`
	fn=`expr $fn : '\(.*\):.*'`
	;;
esac

case "$fn" in
*~*) tilde=true;;
esac
case "$fn" in
*/*) fullpath=true;;
esac
case "$fn" in
*+*) skip=true;;
esac
case "$fn" in
*n*) none_ok=true;;
esac
case "$fn" in
*e*) exp_file=true;;
esac
case "$fn" in
*p*) nopath_ok=true;;
esac

case "$fn" in
*f*) type='File';;
*d*) type='Directory';;
*l*) type='Locate';;
esac

what="$type"
case "$what" in
Locate) what='File';;
esac

case "$exp_file" in
'')
	case "$d_portable" in
	"$define") ;;
	*) exp_file=true;;
	esac
	;;
esac

cd ..
while test "$type"; do
	redo=''
	rp="$orig_rp"
	dflt="$orig_dflt"
	case "$tilde" in
	true) rp="$rp (~name ok)";;
	esac
	. UU/myread
	if test -f UU/getfile.ok && \
		$contains "^$ans\$" UU/getfile.ok >/dev/null 2>&1
	then
		value="$ans"
		ansexp="$ans"
		break
	fi
	case "$ans" in
	none)
		value=''
		ansexp=''
		case "$none_ok" in
		true) type='';;
		esac
		;;
	*)
		case "$tilde" in
		'') value="$ans"
			ansexp="$ans";;
		*)
			value=`UU/filexp $ans`
			case $? in
			0)
				if test "$ans" != "$value"; then
					echo "(That expands to $value on this system.)"
				fi
				;;
			*) value="$ans";;
			esac
			ansexp="$value"
			case "$exp_file" in
			'') value="$ans";;
			esac
			;;
		esac
		case "$fullpath" in
		true)
			case "$ansexp" in
			/*) value="$ansexp" ;;
			*)
				redo=true
				case "$already" in
				true)
				echo "I shall only accept a full path name, as in /bin/ls." >&4
				echo "Use a ! shell escape if you wish to check pathnames." >&4
					;;
				*)
				echo "Please give a full path name, starting with slash." >&4
					case "$tilde" in
					true)
				echo "Note that using ~name is ok provided it expands well." >&4
						already=true
						;;
					esac
				esac
				;;
			esac
			;;
		esac
		case "$redo" in
		'')
			case "$type" in
			File)
				if test -f "$ansexp"; then
					type=''
				elif test -r "$ansexp" || (test -h "$ansexp") >/dev/null 2>&1
				then
					echo "($value is not a plain file, but that's ok.)"
					type=''
				fi
				;;
			Directory)
				if test -d "$ansexp"; then
					type=''
				fi
				;;
			Locate)
				if test -d "$ansexp"; then
					echo "(Looking for $loc_file in directory $value.)"
					value="$value/$loc_file"
					ansexp="$ansexp/$loc_file"
				fi
				if test -f "$ansexp"; then
					type=''
				fi
				case "$nopath_ok" in
				true)	case "$value" in
					*/*) ;;
					*)	echo "Assuming $value will be in people's path."
						type=''
						;;
					esac
					;;
				esac
				;;
			esac

			case "$skip" in
			true) type='';
			esac

			case "$type" in
			'') ;;
			*)
				if test "$fastread" = yes; then
					dflt=y
				else
					dflt=n
				fi
				rp="$what $value doesn't exist.  Use that name anyway?"
				. UU/myread
				dflt=''
				case "$ans" in
				y*) type='';;
				*) echo " ";;
				esac
				;;
			esac
			;;
		esac
		;;
	esac
done
cd UU
ans="$value"
rp="$orig_rp"
dflt="$orig_dflt"
rm -f getfile.ok
EOSC

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
dflt='/usr/include'
incpath=''
mips_type=''
if $test -f /bin/mips && /bin/mips; then
	echo "Looks like a MIPS system..."
	$cat >usr.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
	if $cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
		dflt='/bsd43/usr/include'
		incpath='/bsd43'
		mips_type='BSD 4.3'
	else
		mips_type='System V'
	fi
	$rm -f usr.c usr.out
	echo "and you're compiling with the $mips_type compiler and libraries."
	xxx_prompt=y
	echo "exit 0" >mips
else
	echo "Doesn't look like a MIPS system."
	xxx_prompt=n
	echo "exit 1" >mips
fi
chmod +x mips
$eunicefix mips
case "$usrinc" in
'') ;;
*) dflt="$usrinc";;
esac
case "$xxx_prompt" in
y)	fn=d/
	echo " "
	rp='Where are the include files you want to use?'
	. ./getfile
	usrinc="$ans"
	;;
*)	usrinc="$dflt"
	;;
esac

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..." >&4
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
chmod 755 cppstdin
wrapper=`pwd`/cppstdin
ok='false'
cd UU

if $test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
	case "$cpprun" in
	'') echo "But let's see if we can live without a wrapper..." ;;
	*)
		if $cpprun $cpplast <testcpp.c >testcpp.out 2>&1 && \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "(And we'll use $cpprun $cpplast to preprocess directly.)"
			ok='true'
		else
			echo "(However, $cpprun $cpplast does not work, let's see...)"
		fi
		;;
	esac
else
	case "$cppstdin" in
	'') ;;
	*)
		echo "Good old $cppstdin $cppminus does not seem to be of any help..."
		;;
	esac
fi

if $ok; then
	: nothing
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	x_cpp="$cc -P"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	x_cpp="$cc -P"
	x_minus='-';
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	x_cpp="$cpp"
	x_minus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	x_cpp="$cpp"
	x_minus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	x_cpp="$wrapper"
	x_minus=''
	echo "Eureka!"
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. ./myread
	x_cpp="$ans"
	x_minus=''
	$x_cpp <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do." >&4
	else
echo "Sorry, I can't get that to work.  Go find one and rerun Configure." >&4
		exit 1
	fi
fi

case "$ok" in
false)
	cppstdin="$x_cpp"
	cppminus="$x_minus"
	cpprun="$x_cpp"
	cpplast="$x_minus"
	set X $x_cpp
	shift
	case "$1" in
	"$cpp")
		echo "Perhaps can we force $cc -E using a wrapper..."
		if $wrapper <testcpp.c >testcpp.out 2>&1; \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "Yup, we can."
			cppstdin="$wrapper"
			cppminus='';
		else
			echo "Nope, we'll have to live without it..."
		fi
		;;
	esac
	case "$cpprun" in
	"$wrapper")
		cpprun=''
		cpplast=''
		;;
	esac
	;;
esac

case "$cppstdin" in
"$wrapper") ;;
*) $rm -f $wrapper;;
esac
$rm -f testcpp.c testcpp.out

: Set private lib path
case "$plibpth" in
'') if ./mips; then
		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
	fi;;
esac
case "$libpth" in
' ') dlist='';;
'') dlist="$loclibpth $plibpth $glibpth";;
*) dlist="$libpth";;
esac

: Now check and see which directories actually exist, avoiding duplicates
libpth=''
for xxx in $dlist
do
    if $test -d $xxx; then
		case " $libpth " in
		*" $xxx "*) ;;
		*) libpth="$libpth $xxx";;
		esac
    fi
done
$cat <<'EOM'

Some systems have incompatible or broken versions of libraries.  Among
the directories listed in the question below, please remove any you
know not to be holding relevant libraries, and add any that are needed.
Say "none" for none.

EOM
case "$libpth" in
'') dflt='none';;
*)
	set X $libpth
	shift
	dflt=${1+"$@"}
	;;
esac
rp="Directories to use for library searches?"
. ./myread
case "$ans" in
none) libpth=' ';;
*) libpth="$ans";;
esac

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' ') dflt='none';;
'') case $gccversion in
  2*) dflt='-g -O' ;;
  *egcs*) dflt='-g -O' ;;
  *) dflt='-g' ;;
  esac ;;
*) dflt="$optimize";;
esac
$cat <<EOH

Some C compilers have problems with their optimizers.  By default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want
to use the symbolic debugger, which uses the -g flag (on traditional Unix
systems).  Either flag can be specified here.  To use neither flag, specify
the word "none".

EOH
rp="What optimizer/debugger flag should be used?"
. ./myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac

case "$warnings" in
' ') dflt='none';;
'') case $gccversion in
  2*|egcs*) dflt='-W -Wall -Wno-comment' ;;
  *) dflt='none' ;;
  esac ;;
*) dflt="$warnings";;
esac
$cat <<EOH

EOH
rp="What compiler warning flags should be used?"
. ./myread
warnings="$ans"
case "$warnings" in
'none') warnings=" ";;
esac

dflt=''
: We will not override a previous value, but we might want to
: augment a hint file
case "$hint" in
none|recommended)
	case "$gccversion" in
	1*) dflt='-fpcc-struct-return' ;;
	esac
	case "$gccversion" in
	2*) if test -d /etc/conf/kconfig.d &&
			$contains _POSIX_VERSION $usrinc/sys/unistd.h >/dev/null 2>&1
		then
			dflt="$dflt -posix"
		fi
		;;
	esac
	;;
esac

case "$mips_type" in
*BSD*|'') inclwanted="$locincpth $usrinc";;
*) inclwanted="$locincpth $inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
			*$thisincl*);;
			*) dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

inctest='if $contains $2 $usrinc/$1 >/dev/null 2>&1; then
	xxx=true;
elif $contains $2 $usrinc/sys/$1 >/dev/null 2>&1; then
	xxx=true;
else
	xxx=false;
fi;
if $xxx; then
	case "$dflt" in
	*$2*);;
	*) dflt="$dflt -D$2";;
	esac;
fi'

if ./osf1; then
	set signal.h __LANGUAGE_C__; eval $inctest
else
	set signal.h LANGUAGE_C; eval $inctest
fi

case "$hint" in
none|recommended) dflt="$ccflags $dflt" ;;
*) dflt="$ccflags";;
esac

case "$dflt" in
''|' ') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.  If you
want $package to honor its debug switch, you should include -DDEBUG here.

To use no flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. ./myread
case "$ans" in
none) ccflags='';;
*) ccflags="$ans";;
esac

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$gccversion" in
1*) cppflags="$cppflags -D__GNUC__"
esac
case "$mips_type" in
'');;
*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
esac
case "$cppflags" in
'');;
*)
	echo " "
	echo "Let me guess what the preprocessor flags are..." >&4
	set X $cppflags
	shift
	cppflags=''
	$cat >cpp.c <<'EOM'
#define BLURFL foo

BLURFL xx LFRULB
EOM
	previous=''
	for flag in $*
	do
		case "$flag" in
		-*) ftry="$flag";;
		*) ftry="$previous $flag";;
		esac
		if $cppstdin -DLFRULB=bar $ftry $cppminus <cpp.c \
			>cpp1.out 2>/dev/null && \
			$cpprun -DLFRULB=bar $ftry $cpplast <cpp.c \
			>cpp2.out 2>/dev/null && \
			$contains 'foo.*xx.*bar' cpp1.out >/dev/null 2>&1 && \
			$contains 'foo.*xx.*bar' cpp2.out >/dev/null 2>&1
		then
			cppflags="$cppflags $ftry"
			previous=''
		else
			previous="$flag"
		fi
	done
	set X $cppflags
	shift
	cppflags=${1+"$@"}
	case "$cppflags" in
	*-*)  echo "They appear to be: $cppflags";;
	esac
	$rm -f cpp.c cpp?.out
	;;
esac

: flags used in final linking phase
case "$ldflags" in
'') if ./venix; then
		dflt='-i -z'
	else
		dflt=''
	fi
	case "$ccflags" in
	*-posix*) dflt="$dflt -posix" ;;
	esac
	;;
*) dflt="$ldflags";;
esac

: Try to guess additional flags to pick up local libraries.
for thislibdir in $libpth; do
	case " $loclibpth " in
	*" $thislibdir "*)
		case "$dflt " in 
		*"-L$thislibdir "*) ;;
		*)  dflt="$dflt -L$thislibdir" ;;
		esac
		;;
	esac
done

case "$dflt" in
'') dflt='none' ;;
esac

$cat <<EOH

Your C linker may need flags.  For this question you should
include -L/whatever and any other flags used by the C linker, but you
should NOT include libraries like -lwhatever.

Make sure you include the appropriate -L/path flags if your C linker
does not normally search all of the directories you specified above,
namely
	$libpth
To use no flags, specify the word "none".

EOH

rp="Any additional ld flags (NOT including libraries)?"
. ./myread
case "$ans" in
none) ldflags='';;
*) ldflags="$ans";;
esac
rmlist="$rmlist pdp11"

: coherency check
echo " "
echo "Checking your choice of C compiler and flags for coherency..." >&4
set X $cc $optimize $ccflags $ldflags try.c -o try
shift
$cat >try.msg <<EOM
I've tried to compile and run a simple program with:

	$*
	./try

and I got the following output:

EOM
$cat > try.c <<'EOF'
#include <stdio.h>
main() { exit(0); }
EOF
dflt=y
if sh -c "$cc $optimize $ccflags try.c -o try $ldflags" >>try.msg 2>&1; then
	if sh -c './try' >>try.msg 2>&1; then
		dflt=n
	else
		echo "The program compiled OK, but exited with status $?." >>try.msg
		rp="You have a problem.  Shall I abort Configure"
		dflt=y
	fi
else
	echo "I can't compile the test program." >>try.msg
	rp="You have a BIG problem.  Shall I abort Configure"
	dflt=y
fi
case "$dflt" in
y)
	$cat try.msg
	case "$knowitall" in
	'')
		echo "(The supplied flags might be incorrect with this C compiler.)"
		;;
	*) dflt=n;;
	esac
	echo " "
	. ./myread
	case "$ans" in
	n*|N*) ;;
	*)	echo "Ok.  Stopping Configure." >&4
		exit 1
		;;
	esac
	;;
n) echo "OK, that should do.";;
esac
$rm -f try try.* core

: Initialize h_fcntl
h_fcntl=false

: Initialize h_sysfile
h_sysfile=false

: compute shared library extension
case "$so" in
'')
	if xxx=`./loc libc.sl X $libpth`; $test -f "$xxx"; then
		dflt='sl'
	else
		dflt='so'
	fi
	;;
*) dflt="$so";;
esac
$cat <<EOM

On some systems, shared libraries may be available.  Answer 'none' if
you want to suppress searching of shared libraries for the remaining
of this configuration.

EOM
rp='What is the file extension used for shared libraries?'
. ./myread
so="$ans"

: Define several unixisms.
: Hints files or command line option can be used to override them.
case "$_a" in
'') _a='.a';;
esac
case "$_o" in
'') _o='.o';;
esac

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..." >&4
case "$libs" in
' '|'') dflt='';;
*) dflt="$libs";;
esac
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
	


    if $test "$thislib" = "resolv"; then
      case " $dflt " in
       *"-lbind "*) echo "We've already found -lbind, so we don't need -lresolv" ;;
       *)

	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib.$so X $libpth` ; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc $thislib$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib${thislib}_s$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l${thislib}_s."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l${thislib}_s";;
		esac
	elif xxx=`./loc Slib$thislib$_a X $xlibpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	else
		echo "No -l$thislib."
	fi

      ;;
     esac
    else

	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib.$so X $libpth` ; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc $thislib$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib${thislib}_s$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l${thislib}_s."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l${thislib}_s";;
		esac
	elif xxx=`./loc Slib$thislib$_a X $xlibpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	else
		echo "No -l$thislib."
	fi

    fi
done
set X $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
' '|'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make executables smaller
but make load time slightly longer.

On some systems, mostly System V Release 3's, the shared library is included
by putting the option "-lc_s" as the last thing on the cc command line when
linking.  Other systems use shared libraries by default.  There may be other
libraries needed to compile $package on your machine as well.  If your system
needs the "-lc_s" option, include it here.  Include any other special libraries
here as well.  Say "none" for none.
EOM

echo " "
rp="Any additional libraries?"
. ./myread
case "$ans" in
none) libs=' ';;
*) libs="$ans";;
esac

: set up the script used to warn in case of inconsistency
cat <<EOS >whoa
$startsh
EOS
cat <<'EOSC' >>whoa
dflt=y
echo " "
echo "*** WHOA THERE!!! ***" >&4
echo "    The $hint value for \$$var on this machine was \"$was\"!" >&4
rp="    Keep the $hint value?"
. ./myread
case "$ans" in
y) td=$was; tu=$was;;
esac
EOSC

: function used to set $1 to $val
setvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
case "$val$was" in
$define$undef) . ./whoa; eval "$var=\$td";;
$undef$define) . ./whoa; eval "$var=\$tu";;
*) eval "$var=$val";;
esac'

echo " "
echo "Checking for GNU C Library..." >&4
cat >gnulibc.c <<EOM
int
main()
{
	return __libc_main();
}
EOM
if $cc $ccflags $ldflags -o gnulibc gnulibc.c $libs >/dev/null 2>&1 && \
  ./gnulibc | $contains '^GNU C Library' >/dev/null 2>&1; then
	val="$define"
	echo "You are using the GNU C Library" >&4
else
cat >gnulibc.c <<EOM
#include <features.h>
int main()
{
#ifdef __GLIBC__
  return 0;
#else
  return 1;
#endif
}
EOM
if $cc $ccflags $ldflags -o gnulibc gnulibc.c $libs >/dev/null 2>&1 && \
  ./gnulibc; then
        val="$define"
        echo "You are using the GNU C Library" >&4
else
	val="$undef"
	echo "You are not using the GNU C Library" >&4
fi
fi
$rm -f gnulibc*
set d_gnulibc
eval $setvar

: see if nm is to be used to determine whether a symbol is defined or not
case "$usenm" in
'')
	case "$d_gnulibc" in
	$define)
		dflt=n
		;;
	*)
		dflt=`egrep 'inlibc|csym' ../Configure | wc -l 2>/dev/null`
		if $test $dflt -gt 20; then
			dflt=y
		else
			dflt=n
		fi
		;;
	esac
	;;
*)
	case "$usenm" in
	true) dflt=y;;
	*) dflt=n;;
	esac
	;;
esac
$cat <<EOM

I can use 'nm' to extract the symbols from your C libraries. This is a time
consuming task which may generate huge output on the disk (up to 3 megabytes)
but that should make the symbols extraction faster. The alternative is to skip
the 'nm' extraction part and to compile a small test program instead to
determine whether each symbol is present. If you have a fast C compiler and/or
if your 'nm' output cannot be parsed, this may be the best solution.
If you see a lot of messages about functions NOT found that you know you
have, re-run Configure and don't let me use 'nm'.

EOM
rp='Shall I use nm to extract C symbols from the libraries?'
. ./myread
case "$ans" in
n|N) usenm=false;;
*) usenm=true;;
esac

runnm=$usenm
case "$reuseval" in
true) runnm=false;;
esac

: nm options which may be necessary
case "$nm_opt" in
'') if $test -f /mach_boot; then
		nm_opt=''
	elif $test -d /usr/ccs/lib; then
		nm_opt='-p'
	elif $test -f /dgux; then
		nm_opt='-p'
	else
		nm_opt=''
	fi;;
esac

: nm options which may be necessary for shared libraries but illegal
: for archive libraries.  Thank you, Linux.
case "$nm_so_opt" in
'')	case "$myuname" in
	*linux*)
		if nm --help | $grep 'dynamic' > /dev/null 2>&1; then
			nm_so_opt='--dynamic'
		fi
		;;
	esac
	;;
esac

case "$runnm" in
true)
: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown
	case "$libs" in
	*-lc_s*) libc=`./loc libc_s$_a $libc $libpth`
	esac
	;;
esac
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-lc|-lc_s)
		: Handle C library specially below.
		;;
	-l*)
		thislib=`echo $thislib | $sed -e 's/^-l//'`
		if try=`./loc lib$thislib.$so.'*' X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib.$so X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib$_a X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc $thislib$_a X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc $thislib X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc Slib$thislib$_a X $xlibpth`; $test -f "$try"; then
			:
		else
			try=''
		fi
		libnames="$libnames $try"
		;;
	*) libnames="$libnames $thislib" ;;
	esac
	done
	;;
esac
xxx=normal
case "$libc" in
unknown)
	set /lib/libc.$so
	for xxx in $libpth; do
		$test -r $1 || set $xxx/libc.$so
		$test -r $1 || \
			set `echo blurfl; echo $xxx/libc.$so.[0-9]* | \
			tr ' ' '\012' | egrep -v '\.[A-Za-z]*$' | $sed -e '
				h
				s/[0-9][0-9]*/0000&/g
				s/0*\([0-9][0-9][0-9][0-9][0-9]\)/\1/g
				G
				s/\n/ /' | \
			 sort | $sed -e 's/^.* //'`
		eval set \$$#
	done
	$test -r $1 || set /usr/ccs/lib/libc.$so
	$test -r $1 || set /lib/libsys_s$_a
	;;
*)
	set blurfl
	;;
esac
if $test -r "$1"; then
	echo "Your (shared) C library seems to be in $1."
	libc="$1"
elif $test -r /lib/libc && $test -r /lib/clib; then
	echo "Your C library seems to be in both /lib/clib and /lib/libc."
	xxx=apollo
	libc='/lib/clib /lib/libc'
	if $test -r /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
elif $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	echo "Your C library seems to be in $libc, as you said before."
elif $test -r $incpath/usr/lib/libc$_a; then
	libc=$incpath/usr/lib/libc$_a;
	echo "Your C library seems to be in $libc.  That's fine."
elif $test -r /lib/libc$_a; then
	libc=/lib/libc$_a;
	echo "Your C library seems to be in $libc.  You're normal."
else
	if tans=`./loc libc$_a blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc libc blurfl/dyick $libpth`; $test -r "$tans"; then
		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
	elif tans=`./loc clib blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Slibc$_a blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Mlibc$_a blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	else
		tans=`./loc Llibc$_a blurfl/dyick $xlibpth`
	fi
	if $test -r "$tans"; then
		echo "Your C library seems to be in $tans, of all places."
		libc=$tans
	else
		libc='blurfl'
	fi
fi
if $test $xxx = apollo -o -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	dflt="$libc"
	cat <<EOM

If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.

EOM
else
	dflt=''
	echo $libpth | tr ' ' '\012' | sort | uniq > libpath
	cat >&4 <<EOM
I can't seem to find your C library.  I've looked in the following places:

EOM
	$sed 's/^/	/' libpath
	cat <<EOM

None of these seems to contain your C library. I need to get its name...

EOM
fi
fn=f
rp='Where is your C library?'
. ./getfile
libc="$ans"

echo " "
echo $libc $libnames | tr ' ' '\012' | sort | uniq > libnames
set X `cat libnames`
shift
xxx=files
case $# in 1) xxx=file; esac
echo "Extracting names from the following $xxx for later perusal:" >&4
echo " "
$sed 's/^/	/' libnames >&4
echo " "
$echo $n "This may take a while...$c" >&4

for file in $*; do
	case $file in
	*$so*) nm $nm_so_opt $nm_opt $file 2>/dev/null;;
	*) nm $nm_opt $file 2>/dev/null;;
	esac
done >libc.tmp

$echo $n ".$c"
$grep fprintf libc.tmp > libc.ptf
xscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c" >&4'
xrun='eval "<libc.tmp $com >libc.list"; echo "done" >&4'
xxx='[ADTSIW]'
if com="$sed -n -e 's/__IO//' -e 's/^.* $xxx  *_[_.]*//p' -e 's/^.* $xxx  *//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/Def. Text/s/.* \([^ ]*\)\$/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^[-0-9a-f ]*_\(.*\)=.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/.*\.text n\ \ \ \.//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
else
	nm -p $* 2>/dev/null >libc.tmp
	$grep fprintf libc.tmp > libc.ptf
	if com="$sed -n -e 's/^.* [ADTSIW]  *_[_.]*//p' -e 's/^.* [ADTSIW] //p'";\
		eval $xscan; $contains '^fprintf$' libc.list >/dev/null 2>&1
	then
		nm_opt='-p'
		eval $xrun
	else
		echo " "
		echo "nm didn't seem to work right. Trying ar instead..." >&4
		com=''
		if ar t $libc > libc.tmp; then
			for thisname in $libnames; do
				ar t $thisname >>libc.tmp
			done
			$sed -e "s/\\$_o\$//" < libc.tmp > libc.list
			echo "Ok." >&4
		else
			echo "ar didn't seem to work right." >&4
			echo "Maybe this is a Cray...trying bld instead..." >&4
			if bld t $libc | $sed -e 's/.*\///' -e "s/\\$_o:.*\$//" > libc.list
			then
				for thisname in $libnames; do
					bld t $libnames | \
					$sed -e 's/.*\///' -e "s/\\$_o:.*\$//" >>libc.list
					ar t $thisname >>libc.tmp
				done
				echo "Ok." >&4
			else
				echo "That didn't work either.  Giving up." >&4
				exit 1
			fi
		fi
	fi
fi
nm_extract="$com"
if $test -f /lib/syscalls.exp; then
	echo " "
	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..." >&4
	$sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
fi
;;
esac
$rm -f libnames libpath

: is a C symbol defined?
csym='tlook=$1;
case "$3" in
-v) tf=libc.tmp; tc=""; tdc="";;
-a) tf=libc.tmp; tc="[0]"; tdc="[]";;
*) tlook="^$1\$"; tf=libc.list; tc="()"; tdc="()";;
esac;
tx=yes;
case "$reuseval-$4" in
true-) ;;
true-*) tx=no; eval "tval=\$$4"; case "$tval" in "") tx=yes;; esac;;
esac;
case "$tx" in
yes)
	case "$runnm" in
	true)
		if $contains $tlook $tf >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;;
	*)
		echo "main() { extern short $1$tdc; printf(\"%hd\", $1$tc); }" > t.c;
		if $cc $ccflags $ldflags -o t t.c $libs >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;
		$rm -f t t.c;;
	esac;;
*)
	case "$tval" in
	$define) tval=true;;
	*) tval=false;;
	esac;;
esac;
eval "$2=$tval"'

: define an is-in-libc? function
inlibc='echo " "; td=$define; tu=$undef;
sym=$1; var=$2; eval "was=\$$2";
tx=yes;
case "$reuseval$was" in
true) ;;
true*) tx=no;;
esac;
case "$tx" in
yes)
	set $sym tres -f;
	eval $csym;
	case "$tres" in
	true)
		echo "$sym() found." >&4;
		case "$was" in $undef) . ./whoa; esac; eval "$var=\$td";;
	*)
		echo "$sym() NOT found." >&4;
		case "$was" in $define) . ./whoa; esac; eval "$var=\$tu";;
	esac;;
*)
	case "$was" in
	$define) echo "$sym() found." >&4;;
	*) echo "$sym() NOT found." >&4;;
	esac;;
esac'

: determine filename position in cpp output
echo " "
echo "Computing filename position in cpp output for #include directives..." >&4
echo '#include <stdio.h>' > foo.c
$cat >fieldn <<EOF
$startsh
$cppstdin $cppflags $cppminus <foo.c 2>/dev/null | \
$grep '^[ 	]*#.*stdio\.h' | \
while read cline; do
	pos=1
	qline=\`echo "\$cline" | $sed -e 's/\\([][{}#$<>;&()|^*?\\\\]\\)/\\\\\\\\\\1/g'\`
	eval set \$qline
	while $test "x\$1" \!= x; do
		if $test -r "\$1"; then
			echo "\$pos"
			exit 0
		fi
		shift
		pos=\`expr \$pos + 1\`
	done
done
EOF
chmod +x fieldn
fieldn=`./fieldn`
$rm -f foo.c fieldn
case $fieldn in
'') pos='???';;
1) pos=first;;
2) pos=second;;
3) pos=third;;
*) pos="${fieldn}th";;
esac
echo "Your cpp writes the filename in the $pos field of the line."

: locate header file
$cat >findhdr <<EOF
$startsh
wanted=\$1
name=''
if test -f $usrinc/\$wanted; then
	echo "$usrinc/\$wanted"
	exit 0
fi
echo "#include <\$wanted>" > foo\$\$.c
$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
$grep "^[ 	]*#.*\$wanted" | \
while read cline; do
	pos=1
	qline=\`echo "\$cline" | $sed -e 's/\\([][{}#$<>;&()|^'"'"'*?\\\\]\\)/\\\\\\\\\\1/g'\`
	eval set \$qline
        while $test $fieldn -gt \$pos; do
		shift
		pos=\`expr \$pos + 1\`
	done
	name=\$1
	case "\$name" in
	*/\$wanted) echo "\$name"; exit 0;;
	*\\\\\$wanted) echo "\$name"; exit 0;;
	*) name='';;
	esac;
done;
$rm -f foo\$\$.c;
case "\$name" in
'') exit 1;;
esac
EOF
chmod +x findhdr

: access call always available on UNIX
set access d_access
eval $inlibc

: locate the flags for 'access()'
case "$d_access" in
"$define")
	echo " "
	$cat >access.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
#ifdef I_UNISTD
#include <unistd.h>
#endif
main() {
	exit(R_OK);
}
EOCP
	: check sys/file.h first, no particular reason here
	if $test `./findhdr sys/file.h` && \
		$cc $cppflags -DI_SYS_FILE access.c -o access >/dev/null 2>&1 ; then
		h_sysfile=true;
		echo "<sys/file.h> defines the *_OK access constants." >&4
	elif $test `./findhdr fcntl.h` && \
		$cc $cppflags -DI_FCNTL access.c -o access >/dev/null 2>&1 ; then
		h_fcntl=true;
		echo "<fcntl.h> defines the *_OK access constants." >&4
	elif $test `./findhdr unistd.h` && \
		$cc $cppflags -DI_UNISTD access.c -o access >/dev/null 2>&1 ; then
		echo "<unistd.h> defines the *_OK access constants." >&4
	else
		echo "I can't find the four *_OK access constants--I'll use mine." >&4
	fi
	;;
esac
$rm -f access*

: check for ok to use function ptr arguments in prototypes
echo " "
$cat >test_argsinfp.c <<'EOCP'
#include <stdio.h>
int myfun(int);
int fun(int (*func)(int)); 
int fun2(int, int (*prevfun)(int(*func)(int)));
int fun (int (*func)(int)) { int a = 1; return func(a); }
int myfun(int x) { return x - 1; }

int main(int argc, char **argv) {
 exit(fun(myfun));
} 
EOCP

if $cc $ccflags $ldflags -o test_argsinfp test_argsinfp.c >/dev/null 2>&1 ; then
    d_argsinfp='define'
    echo 'Your compiler prefers arguments in function pointers in prototypes.' >&4
else
    d_argsinfp='undef'
    echo "Your compiler prefers no arguments in function pointers in prototypes." >&4
fi
$rm -f test_argsinfp* core

: see if we have the assert macro
echo " "
echo "Let's see if I can assert() myself." >&4
	$cat >d_assert.c <<EOCP
#include <assert.h>
#include <stdlib.h>

int main()
{
	assert(1);
}
EOCP

if $cc $ccflags $ldflags d_assert.c -o d_assert $libs >/dev/null 2>&1; then
		val="$define"
		set d_assert; eval $setvar
		echo "Looks like I can." >&4
else
		val="$undef"
		set d_assert; eval $setvar
		echo "Nope, I need assertiveness training." >&4
fi
$rm -f d_assert*

: Look for GNU-cc style attribute checking
echo " "
echo "Checking whether your compiler can handle __attribute__ ..." >&4
$cat >attrib.c <<'EOCP'
#include <stdio.h>
void croak (char* pat,...) __attribute__((format(printf,1,2),noreturn));
EOCP
if $cc $optimize $ccflags -c attrib.c >attrib.out 2>&1 ; then
	if $contains 'warning' attrib.out >/dev/null 2>&1; then
		echo "Your C compiler doesn't fully support __attribute__."
		val="$undef"
	else
		echo "Your C compiler supports __attribute__."
		val="$define"
	fi
else
	echo "Your C compiler doesn't seem to understand __attribute__ at all."
	val="$undef"
fi
set d_attribut
eval $setvar
$rm -f attrib*

: see if bcopy exists
set bcopy d_bcopy
eval $inlibc

: define an alternate in-header-list? function
inhdr='echo " "; td=$define; tu=$undef; yyy=$@;
cont=true; xxf="echo \"<\$1> found.\" >&4";
case $# in 2) xxnf="echo \"<\$1> NOT found.\" >&4";;
*) xxnf="echo \"<\$1> NOT found, ...\" >&4";;
esac;
case $# in 4) instead=instead;; *) instead="at last";; esac;
while $test "$cont"; do
	xxx=`./findhdr $1`
	var=$2; eval "was=\$$2";
	if $test "$xxx" && $test -r "$xxx";
	then eval $xxf;
	eval "case \"\$$var\" in $undef) . ./whoa; esac"; eval "$var=\$td";
		cont="";
	else eval $xxnf;
	eval "case \"\$$var\" in $define) . ./whoa; esac"; eval "$var=\$tu"; fi;
	set $yyy; shift; shift; yyy=$@;
	case $# in 0) cont="";;
	2) xxf="echo \"but I found <\$1> $instead.\" >&4";
		xxnf="echo \"and I did not find <\$1> either.\" >&4";;
	*) xxf="echo \"but I found <\$1\> instead.\" >&4";
		xxnf="echo \"there is no <\$1>, ...\" >&4";;
	esac;
done;
while $test "$yyy";
do set $yyy; var=$2; eval "was=\$$2";
	eval "case \"\$$var\" in $define) . ./whoa; esac"; eval "$var=\$tu";
	set $yyy; shift; shift; yyy=$@;
done'

: see if libintl.h can be included
set libintl.h i_libintl
eval $inhdr
: check for a new-style definitions
echo " "
$cat >test_bindtextdomain.c <<EOCP
#$i_libintl I_LIBINTL
#ifdef I_LIBINTL
#include <libintl.h>
#endif
int main(int argc, char **argv) {
   return (int) bindtextdomain ("", "");
}
EOCP

if $cc $ccflags $ldflags -o test_bindtextdomain test_bindtextdomain.c $libs >/dev/null 2>&1 ; then
    d_bindtextdomain='define'
    echo 'Otima! You seem to have bindtextdomain for translations.' >&4
else
    d_bindtextdomain='undef'
    echo "You don't seem to have bindtextdomain. Sinto muito." >&4
fi
$rm -f test_bindtextdomain* core

: see if this is a unistd.h system
set unistd.h i_unistd
eval $inhdr

: see if setpgrp exists
set setpgrp d_setpgrp
eval $inlibc

case "$d_setpgrp" in
"$define")
	echo " "
	echo "Checking to see which flavor of setpgrp is in use..."
	$cat >set.c <<EOP
#$i_unistd I_UNISTD
#include <sys/types.h>
#ifdef I_UNISTD
#  include <unistd.h>
#endif
main()
{
	if (getuid() == 0) {
		printf("(I see you are running Configure as super-user...)\n");
		setuid(1);
	}
#ifdef TRY_BSD_PGRP
	if (-1 == setpgrp(1, 1))
		exit(0);
#else
	if (setpgrp() != -1)
		exit(0);
#endif
	exit(1);
}
EOP
	if $cc -DTRY_BSD_PGRP $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1 && ./set; then
		echo 'You have to use setpgrp(pid,pgrp) instead of setpgrp().' >&4
		val="$define"
	elif $cc $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1 && ./set; then
		echo 'You have to use setpgrp() instead of setpgrp(pid,pgrp).' >&4
		val="$undef"
	else
		echo "(I can't seem to compile and run the test program.)"
		if ./usg; then
			xxx="a USG one, i.e. you use setpgrp()."
		else
			# SVR4 systems can appear rather BSD-ish.
			case "$i_unistd" in
			$undef)
				xxx="a BSD one, i.e. you use setpgrp(pid,pgrp)."
				val="$define"
				;;
			$define)
				xxx="probably a USG one, i.e. you use setpgrp()."
				val="$undef"
				;;
			esac
		fi
		echo "Assuming your setpgrp is $xxx" >&4
	fi
	;;
*) val="$undef";;
esac
set d_bsdsetpgrp
eval $setvar
$rm -f set set.c
: see if bzero exists
set bzero d_bzero
eval $inlibc

: check for const keyword
echo " "
echo 'Checking to see if your C compiler knows about "const"...' >&4
$cat >const.c <<'EOCP'
typedef struct spug { int drokk; } spug;
main()
{
	const char *foo;
	const spug y;
}
EOCP
if $cc -c $ccflags const.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_const
eval $setvar

: see if crypt exists
echo " "
if set crypt val -f d_crypt; eval $csym; $val; then
	echo 'crypt() found.' >&4
	val="$define"
	cryptlib=''
else
	cryptlib=`./loc Slibcrypt.a "" $xlibpth`
	if $test -z "$cryptlib"; then
		cryptlib=`./loc Mlibcrypt.a "" $xlibpth`
	else
		cryptlib=-lcrypt
	fi
	if $test -z "$cryptlib"; then
		cryptlib=`./loc Llibcrypt.a "" $xlibpth`
	else
		cryptlib=-lcrypt
	fi
	if $test -z "$cryptlib"; then
		cryptlib=`./loc libcrypt.a "" $libpth`
	else
		cryptlib=-lcrypt
	fi
	if $test -z "$cryptlib"; then
		echo 'crypt() NOT found!' >&4
		val="$undef"
	else
		val="$define"
	fi
fi
set d_crypt
eval $setvar
: see if crypt.h can be included
set crypt.h i_crypt
eval $inhdr

: Do nothing by default
val="$undef"
set d_force_ipv4; eval $setvar

echo " "
: see if floatingpoint.h can be included
set floatingpoint.h i_floatingpoint
eval $inhdr

: see if fpsetround exists
$cat >test_fpsetround.c <<'EOCP'
#$i_floatingpoint I_FLOATINGPOINT
#ifdef I_FLOATINGPOINT
#include <floatingpoint.h>
#endif

int main() {
	fpsetround(FP_RN);
}
EOCP

if ($cc $ccflags $ldflags -o test_fpsetround test_fpsetround.c $libs \
	&& ./test_fpsetround) >/dev/null 2>&1 ; then
	echo 'fpsetround() is around (and found).' >&4
	val="$define"
else
	echo 'no fpsetround(). No problem.' >&4
        val="$undef"
fi
set d_fpsetround
eval $setvar

: see if fpsetmask exists
$cat >test_fpsetmask.c <<'EOCP'
#$i_floatingpoint I_FLOATINGPOINT
#ifdef I_FLOATINGPOINT
#include <floatingpoint.h>
#endif

int main() {
	fpsetmask(0L);
}
EOCP

if ($cc $ccflags $ldflags -o test_fpsetmask test_fpsetmask.c $libs && \
	./test_fpsetmask) >/dev/null 2>&1 ; then
	echo 'fpsetmask() is up to the task.' >&4
	val="$define"
else
	echo 'no fpsetmask(). No problem.' >&4
        val="$undef"
fi
set d_fpsetmask
eval $setvar

$rm -f test_fpset* core

: see if gai_strerror exists
set gai_strerror d_gaistr
eval $inlibc

: see if getaddrinfo exists
set getaddrinfo d_getadinf
eval $inlibc

: see which of string.h or strings.h is needed
echo " "
strings=`./findhdr string.h`
if $test "$strings" && $test -r "$strings"; then
	echo "Using <string.h> instead of <strings.h>." >&4
	val="$define"
else
	val="$undef"
	strings=`./findhdr strings.h`
	if $test "$strings" && $test -r "$strings"; then
		echo "Using <strings.h> instead of <string.h>." >&4
	else
		echo "No string header found -- You'll surely have problems." >&4
	fi
fi
set i_string
eval $setvar
case "$i_string" in
"$undef") strings=`./findhdr strings.h`;;
*)	  strings=`./findhdr string.h`;;
esac

: see if getdate exists
set getdate d_getdate
eval $inlibc

if test $d_getdate = 'define'; then
$cat >test_getdate.c <<EOCP
#ifdef I_STRING
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#ifdef __GNUC__
/* Required to get the getdate() prototype on glibc. */
#define __USE_XOPEN_EXTENDED
#endif
#include <time.h>
int main(int argc, char **argv) {
  int i;
  i = getdate_err;
}
EOCP

if $cc $ccflags $ldflags -o test_getdate test_getdate.c $libs >/dev/null 2>&1 ; then
    d_getdate='define'
else
    d_getdate='undef'
    echo "You may have getdate, but it's broken." >&4
fi
$rm -f test_getdate* core

fi

: see if gethostbyname2 exists
set gethostbyname2 d_gethbynm2
eval $inlibc

: see if getnameinfo exists - along with constants we use
set getnameinfo d_getnminf
eval $inlibc

if test $d_getnminf = 'define'; then

echo " "
$cat >test_getnminf.c <<EOCP
#include <netdb.h>
int main(int argc, char **argv) {
  int i;
  i = NI_MAXHOST + NI_MAXSERV + NI_NOFQDN + NI_NUMERICHOST + NI_NAMEREQD;
  i += NI_NUMERICSERV + NI_DGRAM;
}
EOCP

if $cc $ccflags $ldflags -o test_getnminf test_getnminf.c $libs >/dev/null 2>&1 ; then
    d_getnminf='define'
    echo "You've got getnameinfo and the netdb constants." >&4
else
    d_getnminf='undef'
    echo "You've got getnameinfo but not the NI_* constants! Broken!" >&4
fi
$rm -f test_getnminf* core

fi
: see if sysctl exists
set sysctl d_sysctl
eval $inlibc
: see if sysctlbyname exists
set sysctlbyname d_sysctlbyname
eval $inlibc

: see if getpagesize exists
set getpagesize d_getpagsz
eval $inlibc

: determine the system page size
echo " "
guess=' (OK to guess)'
case "$pagesize" in
'')
    $cat >page.c <<EOP
#include <stdio.h>
extern int getpagesize();
int main()
{
    printf("%d\n", getpagesize());
}
EOP
    echo "Computing the granularity of memory management calls..." >&4
    dflt='4096'
    case "$d_getpagsz" in
    "$define")
        if $cc $ccflags $ldflags page.c -o page $libs >/dev/null 2>&1; then
            dflt=`./page`
            guess=''
        else
            echo "(I can't seem to compile the test program--guessing)"
        fi
        ;;
    *)
        if $cc $ccflags $ldflags page.c -o page $libs -lPW >/dev/null 2>&1; then
            dflt=`./page`
            guess=''
            echo "(For your eyes only: I used the getpagesize() from -lPW.)"
        else
            if $contains PAGESIZE `./findhdr sys/param.h` >/dev/null 2>&1; then
                $cat >page.c <<EOP
#include <sys/param.h>
#include <stdio.h>
int main()
{
    printf("%d\n", PAGESIZE);
}
EOP
                if $cc $ccflags $ldflags page.c -o page $libs >/dev/null 2>&1; then
                    dflt=`./page`
                    guess=''
                    echo "(Using value of PAGESIZE found in <sys/param.h>.)"
                else 
                  if $test "x$d_sysctlbyname" = "x$define"; then
                    $cat >page.c <<EOP
#include <sys/types.h>
#include <sys/sysctl.h>
#include <stdio.h>
int main()
{
  int res, pgsize
  size_t len;
  len = sizeof(pgsize);
  res = sysctlbyname("hw.pagesize",&pgsize,&len,NULL,0);
  if (res < 0)
    res = sysctlbyname("hw_pagesize",&pgsize,&len,NULL,0);
  printf("%d\n", res ? -1 : pgsize);
}
EOP
                    if $cc $ccflags $ldflags page.c -o page $libs >/dev/null 2>&1; then
                      dflt=`./page`
                      if $test $dflt -gt 0; then
			guess=''
			echo "(Using value from sysctlbyname)"
                      else
			dflt='4096'
                      fi
                    fi
                  fi
                fi
            fi
        fi
        ;;
    esac
    ;;
*) dflt="$pagesize"; guess='';;
esac
rp="What is the system page size, in bytes$guess?"
. ./myread
pagesize=$ans
$rm -f page.c page

: see if getpriority exists
set getpriority d_getprior
eval $inlibc

: see if getdtablesize exists
echo " "
case "$d_gettblsz" in
$define) d_gettblsz="$undef";;
$undef) d_gettblsz="$define";;
esac
if set getdtablesize val -f d_gettblsz; eval $csym; $val; then
	echo 'getdtablesize() found.' >&4
	d_gettblsz="$undef"
	tablesize=''
else
	echo 'getdtablesize() NOT found...' >&4
	if set ulimit val -f; eval $csym; $val; then
		echo 'Maybe ulimit(4,0) will work...'
		$cat >nofile.c <<'EOCP'
#include <stdio.h>
#ifdef GETPARAM_H
#include <sys/param.h>
#endif
main()
{
	printf("%d %d\n",
#ifdef NOFILE
		NOFILE,
#else
		0,
#endif
		ulimit(4,0));
		exit(0);
}
EOCP
		if $cc $ccflags -DGETPARAM_H nofile.c -o nofile $libs >/dev/null 2>&1 \
			|| $cc $ccflags nofile.c -o nofile $libs >/dev/null 2>&1 ; then
			set `./nofile`
			d_gettblsz=$1
			d_ulimit4=$2
			if $test "$d_ulimit4" -lt 0; then
				echo "Your ulimit() call doesn't tell me what I want to know."
				echo "We'll just use NOFILE in this case."
				nofile=$d_gettblsz
				d_gettblsz="$define"
				tablesize='NOFILE'
			else
				if $test "$d_gettblsz" -gt 0; then
				echo "Your system defines NOFILE to be $d_gettblsz, and" >&4
				else
				echo "I had trouble getting NOFILE from your system, but" >&4
				fi
echo "ulimit returns $d_ulimit4 as the number of available file descriptors." >&4
				dflt='y';
				echo " "
	rp='Should I use ulimit to get the number of available file descriptors?'
				. ./myread
				case "$ans" in
				y*)
					nofile=$d_ulimit4
					d_gettblsz="$define"
					tablesize='ulimit(4, 0L)'
					echo "Using ulimit(4,0)."
					;;
				*)
					nofile=$d_gettblsz
					d_gettblsz="$define"
					tablesize='NOFILE'
					echo "Using NOFILE."
					;;
				esac
			fi
		else
			echo "Strange, I couldn't get my test program to compile."
			echo "We'll just use NOFILE in this case."
			d_gettblsz="$define"
			tablesize='NOFILE'
			nofile=''
		fi
	else
		echo 'Using NOFILE instead.'
		d_gettblsz="$define"
		tablesize='NOFILE'
		nofile=''
	fi
fi
$rm -f nofile*

: check for a new-style definitions
echo " "
$cat >test_gettext.c <<EOCP
#$i_libintl I_LIBINTL
#ifdef I_LIBINTL
#include <libintl.h>
#endif
int main(int argc, char **argv) {
   return (int) gettext ("");
}
EOCP

if $cc $ccflags $ldflags -o test_gettext test_gettext.c $libs >/dev/null 2>&1 ; then
    d_gettext='define'
    echo 'Voila! You seem to have gettext for translations.' >&4
else
    d_gettext='undef'
    echo "You don't seem to have gettext. Quel dommage." >&4
fi
$rm -f test_gettext* core

: see if this is a values.h system
set values.h i_values
eval $inhdr

: see if this is a limits.h system
set limits.h i_limits
eval $inhdr

: see if we have HUGE, HUGE_VAL, MAXINT, or MAXDOUBLE
echo " "
echo "Let's try to figure out a really big double." >&4
	$cat >d_huge.c <<EOCP
#include <stdio.h>
#include <math.h>
#$i_values I_VALUES
#$i_limits I_LIMITS
#ifdef I_LIMITS
#include <limits.h>
#else
#ifdef I_VALUES
#include <values.h>
#endif
#endif

int main()
{
	printf("%f\n",HUGE_VAL);
}
EOCP
	if $cc $ccflags $ldflags d_huge.c -o d_huge $libs >/dev/null 2>&1; then
		val="$define"
		set d_huge_val; eval $setvar
		val="$undef"
		set d_huge; eval $setvar
		set d_maxdouble; eval $setvar
		echo "Great. Your system defines HUGE_VAL." >&4
	else
		val="$undef"
		set d_huge_val; eval $setvar
		echo "Your system doesn't have HUGE_VAL. Maybe HUGE?" >&4
	$cat >d_huge.c <<EOCP
#include <stdio.h>
#include <math.h>
#$i_values I_VALUES
#$i_limits I_LIMITS
#ifdef I_LIMITS
#include <limits.h>
#else
#ifdef I_VALUES
#include <values.h>
#endif
#endif
int main()
{
	printf("%f\n",HUGE);
}
EOCP

	if $cc $ccflags $ldflags d_huge.c -o d_huge $libs >/dev/null 2>&1; then
		val="$define"
		set d_huge; eval $setvar
		val="$undef"
		set d_maxdouble; eval $setvar
		echo "Good. Your system defines HUGE." >&4
	else
		val="$undef"
		set d_huge; eval $setvar
		echo "Hmm. Your system doesn't define HUGE. MAX_DOUBLE?" >&4
		$cat >d_huge.c <<EOCP
#include <stdio.h>
#include <math.h>
#$i_limits I_LIMITS
#ifdef I_LIMITS
#include <limits.h>
#else
#$i_values I_VALUES
#ifdef I_VALUES
#include <values.h>
#endif
#endif
int main()
{
	printf("%f\n",MAX_DOUBLE);
}
EOCP

		if $cc $ccflags $ldflags d_huge.c -o d_huge $libs >/dev/null 2>&1; then
			val="$define"
			echo "Ok, you've got MAXDOUBLE." >&4
		else
			val="$undef"
			echo "Nope, no MAXDOUBLE either. We'll guess one." >&4
		fi
		set d_maxdouble; eval $setvar
	fi
fi


echo " "
echo "Let's try to figure out a really big int, too." >&4
		$cat >d_huge.c <<EOCP
#include <stdio.h>
#include <math.h>
#$i_limits I_LIMITS
#ifdef I_LIMITS
#include <limits.h>
#else
#$i_values I_VALUES
#ifdef I_VALUES
#include <values.h>
#endif
#endif
int main()
{
	printf("%d\n",INT_MAX);
}
EOCP

if $cc $ccflags $ldflags d_huge.c -o d_huge $libs >/dev/null 2>&1; then
	val="$define"
	set d_int_max; eval $setvar
	val="$undef"
	set d_maxint; eval $setvar
	echo "Ok, you've got INT_MAX." >&4
else
	val="$undef"
	echo "No INT_MAX. Maybe MAXINT?" >&4
	set d_int_max; eval $setvar
	$cat >d_huge.c <<EOCP
#include <stdio.h>
#include <math.h>
#$i_limits I_LIMITS
#ifdef I_LIMITS
#include <limits.h>
#else
#$i_values I_VALUES
#ifdef I_VALUES
#include <values.h>
#endif
#endif
int main()
{
	printf("%d\n",MAXINT);
}
EOCP
	if $cc $ccflags $ldflags d_huge.c -o d_huge $libs >/dev/null 2>&1; then
		val="$define"
		echo "Ok, you've got MAXINT." >&4
		set d_maxint; eval $setvar
	else
		val="$undef"
		echo "No MAXINT. I give up. I'll take a guess." >&4
		set d_maxint; eval $setvar
	fi
fi

$rm -f d_huge*

: check for a safe ieee
echo " "
echo "Let's see if your math functions handle errors nicely..." >&4
$cat >test_ieee.c <<'EOCP'
#include <stdio.h>
#include <math.h>

int main() {
	double x;
	x = pow(-1,.5);
        x = pow(10000,10000);
	printf("define\n");
	exit(0);
}
EOCP

if $cc $ccflags $ldflags -o test_ieee test_ieee.c -lm >/dev/null 2>&1 ; then
    d_ieee=`./test_ieee`
    if test $d_ieee = define ; then
	echo "Great! They can." >&4
    else
   	echo "Nope, they crash and burn." >&4
	d_ieee='undef'
    fi
else
	$cat <<EOM
(I can't seem to get my test program to work. We'll play it safe
 and assume that your math functions don't handle errors nicely.)
EOM
    d_ieee='undef'
fi
$rm -f test_ieee* core

: see inet_pton exists
set inet_pton d_in2p
eval $inlibc

: index or strchr
echo " "
if set index val -f; eval $csym; $val; then
	if set strchr val -f d_strchr; eval $csym; $val; then
		if $contains strchr "$strings" >/dev/null 2>&1 ; then
			val="$define"
			vali="$define"
			echo "strchr() and index() found." >&4
		else
			val="$undef"
			vali="$define"
			echo "index() found." >&4
		fi
	else
		val="$undef"
		vali="$define"
		echo "index() found." >&4
	fi
else
	if set strchr val -f d_strchr; eval $csym; $val; then
		val="$define"
		vali="$undef"
		echo "strchr() found." >&4
	else
		echo "No index() or strchr() found!" >&4
		val="$undef"
		vali="$undef"
	fi
fi
set d_strchr; eval $setvar
val="$vali"
set d_index; eval $setvar

: check for internet mailer
dflt=y
case "$d_internet" in
"$undef") dflt=n;;
esac
cat <<EOM
 
Most mailers can deliver mail to addresses of the INTERNET persuasion,
such as user@host.edu.  Some older mailers, however, require the complete
path to the destination to be specified in the address.

EOM
rp="Does your mailer understand INTERNET addresses?"
. ./myread
case "$ans" in
y*) val="$define";;
*)  val="$undef";;
esac
set d_internet
eval $setvar

: see if sys/types.h has to be included
set sys/types.h i_systypes
eval $inhdr

: see if this is a sys/socket.h system
set sys/socket.h i_syssock
eval $inhdr

: see if this is a netinet/in.h or sys/in.h system
set netinet/in.h i_niin sys/in.h i_sysin
eval $inhdr

: see if we have struct sockaddr_in6.
echo " "
$cat >d_ipv6.c <<EOCP
#$i_systypes I_SYS_TYPES
#$i_syssock I_SYS_SOCK
#$i_niin I_NETINET_IN
#$i_sysin I_SYS_IN
#ifdef I_SYS_TYPES
#include <sys/types.h>
#endif
#ifdef I_SYS_SOCK
#include <sys/socket.h>
#endif
#ifdef I_NETINET_IN
#include <netinet/in.h>
#else
#ifdef I_SYS_IN
#include <sys/in.h>
#endif
#endif
#include <stdio.h>
main()
{
	struct sockaddr_in6 test;
	int foo = AF_INET6;
	printf("%d\n", foo);
}
EOCP
if $cc $ccflags $ldflags d_ipv6.c -o d_ipv6 $libs >/dev/null 2>&1; then
	val="$define"
	set d_ipv6; eval $setvar
	echo "IPv6 structures found." >&4
else
	val="$undef"
	set d_ipv6; eval $setvar
	echo "No IPv6 structures found. No problem." >&4
fi
: see if setitimer exists
set setitimer d_itimer
eval $inlibc

socketlib=''
sockethdr=''
: see whether socket exists
echo " "
$echo $n "Hmm... $c" >&4
if set socket val -f d_socket; eval $csym; $val; then
	echo "Looks like you have Berkeley networking support." >&4
	d_socket="$define"
	if set setsockopt val -f; eval $csym; $val; then
		d_oldsock="$undef"
	else
		echo "...but it uses the old 4.1c interface, rather than 4.2" >&4
		d_oldsock="$define"
	fi
else
	if $contains socklib libc.list >/dev/null 2>&1; then
		echo "Looks like you have Berkeley networking support." >&4
		d_socket="$define"
		: we will have to assume that it supports the 4.2 BSD interface
		d_oldsock="$undef"
	else
		echo "You don't have Berkeley networking in libc$_a..." >&4
		if test -f /usr/lib/libnet$_a; then
			( (nm $nm_opt /usr/lib/libnet$_a | eval $nm_extract) ||  \
			ar t /usr/lib/libnet$_a) 2>/dev/null >> libc.list
			if $contains socket libc.list >/dev/null 2>&1; then
			echo "...but the Wollongong group seems to have hacked it in." >&4
				socketlib="-lnet"
				sockethdr="-I/usr/netinclude"
				d_socket="$define"
				if $contains setsockopt libc.list >/dev/null 2>&1; then
					d_oldsock="$undef"
				else
					echo "...using the old 4.1c interface, rather than 4.2" >&4
					d_oldsock="$define"
				fi
			else
				echo "or even in libnet$_a, which is peculiar." >&4
				d_socket="$undef"
				d_oldsock="$undef"
			fi
		else
			echo "or anywhere else I see." >&4
			d_socket="$undef"
			d_oldsock="$undef"
		fi
	fi
fi

: see if socketpair exists
set socketpair d_sockpair
eval $inlibc

: see if this is a netinet/tcp.h system
set netinet/tcp.h i_nitcp
eval $inhdr

: see if setsockopt with SO_KEEPALIVE works as advertised
echo " "
case "$d_oldsock" in
"$undef")
		echo "OK, let's see if SO_KEEPALIVE works as advertised..." >&4
		$cat > socket.c <<EOP
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#$i_nitcp I_NETINET_TCP
#ifdef I_NETINET_TCP
#include <netinet/tcp.h>
#endif
#include <netdb.h>

main()
{
	int s = socket(AF_INET, SOCK_STREAM, 0);
	int val = 1;
	if (s == -1)
		exit(1);
	if (-1 == setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)))
		exit(2);
#ifdef I_NETINET_TCP
#ifdef TCP_KEEPIDLE
	val = 1;
	if (-1 == setsockopt(s, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)))
		exit(3);
#else
        exit(3);
#endif
#endif
	exit(0);
}
EOP
		if $cc $ccflags $sockethdr socket.c -o socket $libs \
			$socketlib >/dev/null 2>&1; then
			./socket >/dev/null 2>&1
			case $? in
			0) echo "Yes, it does!"
				val="$define"
				val2="$i_nitcp"
			;;
			1) $cat <<EOM
(Something went wrong -- Assuming SO_KEEPALIVE is broken)
EOM
				val="$undef"
				val2="$undef"
			;;
			2) echo "No, it doesn't.  Don't trust your manuals!!"
				val="$undef"
				val2="$undef"
			;;
			3) echo "It does, but TCP_KEEPIDLE doesn't."
				val="$define"
				val2="$undef"
			;;
			esac
		else
			cat <<EOM
(I can't compile the test program -- Assuming SO_KEEPALIVE is broken)
EOM
			val="$undef"
			val2="$undef"
		fi
	;;
*) cat <<EOM
As you have an old socket interface, you can't have heard of SO_KEEPALIVE.
EOM
	val="$undef"
	val2="$undef";;
esac
set d_keepalive
eval $setvar
val="$val2"
set d_keepidle
eval $setvar
$rm -f socket socket.c

echo " "
: see if we have sigaction
if set sigaction val -f d_sigaction; eval $csym; $val; then
	echo 'sigaction() found.' >&4
	val="$define"
else
	echo 'sigaction NOT found.' >&4
	val="$undef"
fi
$cat > set.c <<'EOP'
#include <stdio.h>
#include <sys/types.h>
#include <signal.h>
main()
{
    struct sigaction act, oact;
}
EOP
if $cc $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1; then
	:
else
	echo "But you don't seem to have a useable struct sigaction." >&4
	val="$undef"
fi
set d_sigaction; eval $setvar
$rm -f set set$_o set.c

: see if signals are kept
val="$undef"
echo " "
echo "Checking to see if signal handlers stick around..." >&4
if test ${d_sigaction} = "$define"; then
  echo "You've got sigaction, so we can force 'em to." >&4
  val="$define"
else
  $cat >try.c <<'EOCP'
foo() {}

int main()
{
	signal(2, foo);
	kill(getpid(), 2);
	kill(getpid(), 2);
	printf("abc\n");
}
EOCP
  if $cc -o try $ccflags $ldflags try.c >/dev/null 2>&1; then
	sh -c ./try >try.out 2>/dev/null
	if $contains abc try.out >/dev/null 2>&1; then
		echo "Yes, they do."
		val="$define";
	else
		echo "No, they don't."
	fi
  else
	$echo $n "(I can't seem to compile the test program. Assuming $c"
	if ./bsd; then
		echo "they do.)"
		val="$define"
	else
		echo "they don't.)"
	fi
  fi
fi
set d_keepsig
eval $setvar
$rm -f try*

: random, lrand48, or rand
set random d_random
eval $inlibc
set lrand48 d_lrand48
eval $inlibc
set rand d_rand
eval $inlibc

: see if memcpy exists
set memcpy d_memcpy
eval $inlibc
set memmove d_memmove
eval $inlibc

: see if memset exists
set memset d_memset
eval $inlibc

: see if we should include -lmysqlclient
echo " "

d_mysql="$undef"

if $test "x$no_mysql" = "x"; then

  libmysqlclient="-lmysqlclient"

  $cat > test_mysql.c <<EOM
#include <stdio.h>
#include <stdlib.h>
#include <mysql/mysql.h>
#include <mysql/errmsg.h>

int main(int argc, char **argv) {
   printf("Your mysql is version %s\n",mysql_get_client_info());
   exit(0);
}
EOM

  if $cc $ccflags $ldflags -o test_mysql test_mysql.c $libs $libmysqlclient >/dev/null 2>&1 ;
  then
      echo 'You have mysql...' >&4
      version=`./test_mysql`
      if $test $? -eq 0; then
	echo "$version" >&4
        d_mysql="$define"
      else
        echo "...but my test program didn't run correctly." >&4
        libmysqlclient=''
      fi
  else
      echo "You don't seem to have mysql." >&4
      libmysqlclient=''
  fi
  $rm -f test_mysql* core

else

  echo "Skipping mysql tests." >&4
  libmysqlclient=''

fi

: check for a new-style definitions
echo " "
$cat >test_newstyle.c <<'EOCP'
#include <stdio.h>
int main(int argc, char **argv) {
	exit(0);
}
EOCP

if $cc $ccflags $ldflags -o test_newstyle test_newstyle.c >/dev/null 2>&1 ; then
    d_newstyle='define'
    echo 'Your compiler accepts new-style function definitions.' >&4
else
    d_newstyle='undef'
    echo "Your compiler DOESN'T accept new-style function definitions." >&4
fi
$rm -f test_newstyle* core

: Locate the flags for 'open()'
echo " "
$cat >open3.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
int main() {
	if(O_RDONLY);
#ifdef O_TRUNC
	exit(0);
#else
	exit(1);
#endif
}
EOCP
: check sys/file.h first to get FREAD on Sun
if $test "`./findhdr sys/file.h`" && \
		$cc $ccflags $ldflags "-DI_SYS_FILE" open3.c -o open3 $libs >/dev/null 2>&1 ; then
	h_sysfile=true;
	echo "<sys/file.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
elif $test "`./findhdr fcntl.h`" && \
		$cc $ccflags $ldflags "-DI_FCNTL" open3.c -o open3 $libs >/dev/null 2>&1 ; then
	h_fcntl=true;
	echo "<fcntl.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
else
	val="$undef"
	echo "I can't find the O_* constant definitions!  You got problems." >&4
fi
set d_open3
eval $setvar
$rm -f open3*

: see if we should include -lssl and -lcrypto
echo " "

d_openssl="$undef"

if $test "x$no_openssl" = "x"; then

  libssl="-lssl -lcrypto"

  $cat > test_ssl.c <<EOM
#include <stdio.h>
#include <stdlib.h>
#include <openssl/opensslv.h>
int main(int argc, char **argv) {
   printf("Your openssl is version %lx\n",OPENSSL_VERSION_NUMBER);
   exit(OPENSSL_VERSION_NUMBER < 0x00906000L);
}
EOM

  if $cc $ccflags $ldflags -o test_ssl test_ssl.c $libs $libssl >/dev/null 2>&1 ;
  then
      echo 'You have openssl...' >&4
      version=`./test_ssl`
      if $test $? -eq 0; then
	echo '...and at least version 0.9.6. Great.' >&4
	d_openssl="$define"
      else
	echo '...but not version 0.9.6 or later.' >&4
	libssl=''
      fi
  else
      echo "You don't seem to have openssl." >&4
      libssl=''
  fi
  $rm -f test_ssl* core

else

  echo "Skipping openssl tests." >&4
  libssl=''

fi

: see if rename exists
set rename d_rename
eval $inlibc

: see if getrlimit exists
set getrlimit d_rlimit
eval $inlibc

: see if getrusage exists
set getrusage d_rusage
eval $inlibc

: see if select exists
set select d_select
eval $inlibc

: have we got sendmail?
echo " "
echo "Checking to see if we can use sendmail..."
if $test -f $sendmail; then
        echo "Looks like sendmail is in $sendmail"
	val="$define"
else
	echo "Nope, out of luck."
	val="$undef"
fi
set d_sendmail
eval $setvar

: see if setlocale exists
set setlocale d_setlocale
eval $inlibc

: see if setpgid exists
set setpgid d_setpgid
eval $inlibc

: see if setpriority exists
set setpriority d_setprior
eval $inlibc

: see if we have SIGCHLD, SIGCLD, or both
echo " "
echo "How should a child signal a parent?" >&4
$cat >d_sigchld.c <<EOCP
#include <signal.h>
#include <stdio.h>
int main()
{
	printf("%d\n",SIGCHLD);
}
EOCP
if $cc $ccflags $ldflags d_sigchld.c -o d_sigchld $libs >/dev/null 2>&1; then
	val="$define"
	set d_sigchld; eval $setvar
	echo "SIGCHLD works."
else
	val="$undef"
	set d_sigchld; eval $setvar
	echo "SIGCHLD doesn't work."
fi

$cat >d_sigchld.c <<EOCP
#include <signal.h>
#include <stdio.h>
int main()
{
	printf("%d\n",SIGCLD);
}
EOCP
if $cc $ccflags $ldflags d_sigchld.c -o d_sigchld $libs >/dev/null 2>&1; then
	val="$define"
	set d_sigcld; eval $setvar
	echo "SIGCLD works."
else
	val="$undef"
	set d_sigcld; eval $setvar
	echo "SIGCLD doesn't work."
fi
: Cruising for prototypes
echo " "
echo "Checking out function prototypes..." >&4
$cat >prototype.c <<'EOCP'
main(int argc, char *argv[]) {
	exit(0);}
EOCP
if $cc $ccflags -c prototype.c >prototype.out 2>&1 ; then
	echo "Your C compiler appears to support function prototypes."
	val="$define"
else
	echo "Your C compiler doesn't seem to understand function prototypes."
	val="$undef"
fi
set prototype
eval $setvar
$rm -f prototype*

: see if signal is declared as pointer to function returning int or void
echo " "
xxx=`./findhdr signal.h`
$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
if $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
elif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have void (*signal())() instead of int." >&4
	val="$define"
elif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
else
	case "$d_voidsig" in
	'')
	echo "I can't determine whether signal handler returns void or int..." >&4
		dflt=void
		rp="What type does your signal handler return?"
		. ./myread
		case "$ans" in
		v*) val="$define";;
		*) val="$undef";;
		esac;;
	"$define")
		echo "As you already told me, signal handler returns void." >&4;;
	*)
		echo "As you already told me, signal handler returns int." >&4;;
	esac
fi
set d_voidsig
eval $setvar
case "$d_voidsig" in
"$define") signal_t="void";;
*) signal_t="int";;
esac
$rm -f $$.tmp

: can we prototype signal ourselves
val="$undef"
echo " "
echo "Checking to see if we can declare or prototype signal()..." >&4
if test ${prototype} = "$define"; then
  $cat >try.c <<EOCP
#include <stdio.h>
#include <signal.h>
#ifdef signal
#undef signal
#endif
typedef ${signal_t} (*Sigfunc) (int);
extern Sigfunc signal (int signo, Sigfunc func);
int main()
{ printf("no op\n"); }
EOCP
else
  $cat >try.c <<EOCP
#include <stdio.h>
#include <signal.h>
#ifdef signal
#undef signal
#endif
typedef ${signal_t} (*Sigfunc) ();
extern Sigfunc signal ();
int main()
{ printf("no op\n"); }
EOCP
fi
if $cc -o try $ccflags $ldflags try.c >/dev/null 2>&1; then
	$echo "Looks like we can."
	val="$define";
else
	$echo "Looks like we can't."
fi
set d_signalproto
eval $setvar
$rm -f try*

echo " "
: see if we have sigprocmask
if set sigprocmask val -f d_sigprocmask; eval $csym; $val; then
	echo 'sigprocmask() found.' >&4
	val="$define"
else
	echo 'sigprocmask NOT found.' >&4
	val="$undef"
fi
$cat > set.c <<'EOP'
#include <stdio.h>
#include <sys/types.h>
#include <signal.h>
main()
{
  sigset_t mask, oldmask;
  sigprocmask(SIG_SETMASK, &mask, &oldmask);
}
EOP
if $cc $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1; then
	:
else
	echo "But you don't seem to have a working sigprocmask." >&4
	val="$undef"
fi
set d_sigprocmask; eval $setvar
$rm -f set set$_o set.c

: see if snprintf exists
echo " "
if set snprintf val -f d_snprintf; eval $csym; $val; then
	echo 'snprintf() found.' >&4
	val="$define"
else
	echo 'snprintf() NOT found.' >&4
	val="$undef"
fi
set d_snprintf
eval $setvar

: see if we have socklen_t.
echo " "
$cat >d_socklen.c <<EOCP
#$i_systypes I_SYS_TYPES
#$i_syssock I_SYS_SOCKET
#ifdef I_SYS_TYPES
#include <sys/types.h>
#endif
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#include <stdio.h>
main()
{
	socklen_t test = 1;
	printf("%d\n",test);
}
EOCP
if $cc $ccflags $ldflags d_socklen.c -o d_socklen $libs >/dev/null 2>&1; then
	val="$define"
	set d_socklen; eval $setvar
	echo "socklen_t works." >&4
else
	val="$undef"
	set d_socklen; eval $setvar
	echo "socklen_t doesn't work. Using int." >&4
fi
: see if strcasecmp exists
set strcasecmp d_strccmp
eval $inlibc

: see if strcoll exists
set strcoll d_strcoll
eval $inlibc

: see if strdup exists
set strdup d_strdup
eval $inlibc

: see if strxfrm exists
set strxfrm d_strxfrm
eval $inlibc

: see if sysconf exists
set sysconf d_sysconf
eval $inlibc

: see if tcl exists
echo " "
ok=0

if $test -f src/tcl.c -o -f ../src/tcl.c ; then
  echo "I'm tickled pink - we have the penn TCL source." >&4
  echo "Let's see if we have TCL." >&4

: see if tcl.h can be included
  set tcl.h i_tcl
  eval $inhdr
  if $test $i_tcl = "$define"; then
    echo "We have tcl.h, that's a start." >&4
    : see if the tcl library was found earlier
    case $libs in 
      *tcl*)   val="$define"
               set d_tcl
               eval $setvar
	       echo "We have the TCL library, too." >&4
               ok=1
  	   ;;
      *)       echo "Oops, no TCL library. Check your TCL installation." >&4
	   ;;
    esac
  else
    echo "I can't find tcl.h. Check your TCL installation." >&4
  fi
fi

if $test $ok = 0; then
  nlibs=""
  for l in $libs; do
    case $l in 
      *tcl*) ;;
      *dl*) ;;
      *ld*) ;;
      *) nlibs="$nlibs$l " ;;
    esac
  done
  libs="$nlibs"
  val="$undef"
  set d_tcl
  eval $setvar
  val="$undef"
  set i_tcl
  eval $setvar
else
  echo "TCL will be compiled and included." >&4
fi
: check for a new-style definitions
echo " "
$cat >test_textdomain.c <<EOCP
#$i_libintl I_LIBINTL
#ifdef I_LIBINTL
#include <libintl.h>
#endif
int main(int argc, char **argv) {
   return (int) textdomain ("");
}
EOCP

if $cc $ccflags $ldflags -o test_textdomain test_textdomain.c $libs >/dev/null 2>&1 ; then
    d_textdomain='define'
    echo 'Mabuhay! You seem to have textdomain for translations.' >&4
else
    d_textdomain='undef'
    echo "You don't seem to have textdomain. Sayang." >&4
fi
$rm -f test_textdomain* core

: see if timelocal exists
set timelocal d_timelocal
eval $inlibc

: check for a safe toupper
echo " "
echo "Checking out your toupper()..." >&4
$cat >test_toupper.c <<'EOCP'
#include <stdio.h>
#include <ctype.h>

int main() {
	char c = 'A';
	if (c == toupper(c)) {
	  printf("define\n");
	} else {
	  printf("undef\n");
        }
	exit(0);
}
EOCP

if $cc $ccflags $ldflags -o test_toupper test_toupper.c >/dev/null 2>&1 ; then
    d_toupper=`./test_toupper`
    if test $d_toupper = define ; then
	echo "It's safe toupper uppers." >&4
    else
   	echo "We can't toupper uppers." >&4
    fi
else
	$cat <<EOM
(I can't seem to get my test program to work. We'll play it safe.)
EOM
    d_toupper='undef'
fi
$rm -f test_toupper* core

: uptime
echo " "
if $test -x $uptime ; then
	val="$define"
else
	val="$undef"
fi
set d_uptime; eval $setvar

: see if /dev/urandom is present
echo " "
if $test -c /dev/urandom ; then
	val="$define"
else
	val="$undef"
fi
set d_urandom; eval $setvar

: see if union wait is available
echo " "
set X $cppflags
shift
flags=''
also=''
for f in $*; do
	case "$f" in
	*NO_PROTO*) ;;
	*) flags="$flags $f";;
	esac
done
xxx="`./findhdr sys/wait.h`"
case "x$xxx" in
x) xxx=/dev/null
esac
$cat "$xxx" | $cppstdin $flags $cppminus >wait.out 2>/dev/null
if $contains 'union.*wait.*{' wait.out >/dev/null 2>&1 ; then
	echo "Looks like your <sys/wait.h> knows about 'union wait'..." >&4
	val="$define"
	also='also '
	if $contains 'extern.*wait[ 	]*([ 	]*int' wait.out >/dev/null 2>&1
	then
		echo "But wait() seems to expect an 'int' pointer (POSIX way)." >&4
		val="$undef"
		also=''
	elif $contains 'extern.*wait[ 	]*([ 	]*union' wait.out >/dev/null 2>&1
	then
		echo "And indeed wait() expects an 'union wait' pointer (BSD way)." >&4
	else
		echo "So we'll use that for wait()." >&4
	fi
else
	echo "No trace of 'union wait' in <sys/wait.h>..." >&4
	val="$undef"
	echo "Your wait() should be happy with a plain 'int' pointer." >&4
fi
set d_uwait
eval $setvar
$rm -f wait.out

: get C preprocessor symbols handy
echo " "
$echo $n "Hmm... $c"
echo $al | $tr ' ' '\012' >Cppsym.know
$cat <<EOSS >Cppsym
$startsh
case "\$1" in
-l) list=true
	shift
	;;
esac
unknown=''
case "\$list\$#" in
1|2)
	for sym do
		if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
			exit 0
		elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
			:
		else
			unknown="\$unknown \$sym"
		fi
	done
	set X \$unknown
	shift
	;;
esac
case \$# in
0) exit 1;;
esac
echo \$* | $tr ' ' '\012' | $sed -e 's/\(.*\)/\\
#ifdef \1\\
exit 0; _ _ _ _\1\\	 \1\\
#endif\\
/' >Cppsym\$\$
echo "exit 1; _ _ _" >>Cppsym\$\$
$cppstdin $cppminus <Cppsym\$\$ | $grep '^exit [01]; _ _'  >Cppsym2\$\$
case "\$list" in
true) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
*)
	sh Cppsym2\$\$
	status=\$?
	;;
esac
$rm -f Cppsym\$\$ Cppsym2\$\$
exit \$status
EOSS
chmod +x Cppsym
$eunicefix Cppsym
./Cppsym -l $al | $sort | $grep -v '^$' >Cppsym.true

: now check the C compiler for additional symbols
$cat >ccsym <<EOS
$startsh
$cat >tmp.c <<EOF
extern int foo;
EOF
for i in \`$cc -v -c tmp.c 2>&1\`
do
	case "\$i" in
	-D*) echo "\$i" | $sed 's/^-D//';;
	-A*) $test "$gccversion" && echo "\$i" | $sed 's/^-A\(.*\)(\(.*\))/\1=\2/';;
	esac
done
$rm -f try.c
EOS
chmod +x ccsym
$eunicefix ccsym
./ccsym | $sort | $uniq >ccsym.raw
$awk '/\=/ { print $0; next }
	{ print $0"=1" }' ccsym.raw >ccsym.list
$awk '{ print $0"=1" }' Cppsym.true >ccsym.true
$comm -13 ccsym.true ccsym.list >ccsym.own
$comm -12 ccsym.true ccsym.list >ccsym.com
$comm -23 ccsym.true ccsym.list >ccsym.cpp
also=''
symbols='symbols'
if $test -z ccsym.raw; then
	echo "Your C compiler doesn't seem to define any symbol!" >&4
	echo " "
	echo "However, your C preprocessor defines the following ones:"
	$cat Cppsym.true
else
	if $test -s ccsym.com; then
		echo "Your C compiler and pre-processor define these symbols:"
		$sed -e 's/\(.*\)=.*/\1/' ccsym.com
		also='also '
		symbols='ones'
		$test "$silent" || sleep 1
	fi
	if $test -s ccsym.cpp; then
		$test "$also" && echo " "
		echo "Your C pre-processor ${also}defines the following $symbols:"
		$sed -e 's/\(.*\)=.*/\1/' ccsym.cpp
		also='further '
		$test "$silent" || sleep 1
	fi
	if $test -s ccsym.own; then
		$test "$also" && echo " "
		echo "Your C compiler ${also}defines the following cpp variables:"
		$sed -e 's/\(.*\)=1/\1/' ccsym.own
		$sed -e 's/\(.*\)=.*/\1/' ccsym.own | $uniq >>Cppsym.true
		$test "$silent" || sleep 1
	fi
fi
$rm -f ccsym*

: see if this is a termio system
val="$undef"
val2="$undef"
val3="$undef"
if $test "`./findhdr termios.h`"; then
	set tcsetattr i_termios
	eval $inlibc
	val3="$i_termios"
fi
echo " "
case "$val3" in
"$define") echo "You have POSIX termios.h... good!" >&4;;
*) if ./Cppsym pyr; then
		case "`/bin/universe`" in
		ucb) if $test "`./findhdr sgtty.h`"; then
				val2="$define"
				echo "<sgtty.h> found." >&4
			else
				echo "System is pyramid with BSD universe."
				echo "<sgtty.h> not found--you could have problems." >&4
			fi;;
		*) if $test "`./findhdr termio.h`"; then
				val="$define"
				echo "<termio.h> found." >&4
			else
				echo "System is pyramid with USG universe."
				echo "<termio.h> not found--you could have problems." >&4
			fi;;
		esac
	elif ./usg; then
		if $test "`./findhdr termio.h`"; then
			echo "<termio.h> found." >&4
			val="$define"
		elif $test "`./findhdr sgtty.h`"; then
			echo "<sgtty.h> found." >&4
			val2="$define"
		else
echo "Neither <termio.h> nor <sgtty.h> found--you could have problems." >&4
		fi
	else
		if $test "`./findhdr sgtty.h`"; then
			echo "<sgtty.h> found." >&4
			val2="$define"
		elif $test "`./findhdr termio.h`"; then
			echo "<termio.h> found." >&4
			val="$define"
		else
echo "Neither <sgtty.h> nor <termio.h> found--you could have problems." >&4
		fi
	fi;;
esac
set i_termio; eval $setvar
val=$val2; set i_sgtty; eval $setvar
val=$val3; set i_termios; eval $setvar

: see if ioctl defs are in sgtty, termio, sys/filio or sys/ioctl
set sys/filio.h i_sysfilio
eval $inhdr
echo " "
if $test "`./findhdr sys/ioctl.h`"; then
	val="$define"
	echo '<sys/ioctl.h> found.' >&4
else
	val="$undef"
	if $test $i_sysfilio = "$define"; then
	    echo '<sys/ioctl.h> NOT found.' >&4
	else
		$test $i_sgtty = "$define" && xxx="sgtty.h"
		$test $i_termio = "$define" && xxx="termio.h"
		$test $i_termios = "$define" && xxx="termios.h"
echo "No <sys/ioctl.h> found, assuming ioctl args are defined in <$xxx>." >&4
	fi
fi
set i_sysioctl
eval $setvar

: check how to void tty association
echo " "
case "$i_sysioctl" in
"$define") xxx='sys/ioctl.h';;
esac
$cat > tcio.c <<EOM
#include <sys/types.h>	/* Just in case */
#include <$xxx>

int main()
{
#ifdef TIOCNOTTY
	exit(0);
#else
	exit(1);
#endif
}
EOM
if ($cc -o tcio tcio.c && ./tcio) >/dev/null 2>&1; then
	val="$define"
	echo "TIOCNOTTY found in <$xxx>." >&4
	echo "Using ioctl() call on /dev/tty to void tty association." >&4
else
	val="$undef"
	echo "Closing standard file descriptors should void tty association." >&4
fi
set d_voidtty
eval $setvar
$rm -f tcio tcio.? core

: check for volatile keyword
echo " "
echo 'Checking to see if your C compiler knows about "volatile"...' >&4
$cat >try.c <<'EOCP'
main()
{
	typedef struct _goo_struct goo_struct;
	goo_struct * volatile goo = ((goo_struct *)0);
	struct _goo_struct {
		long long_int;
		int reg_int;
		char char_var;
	};
	typedef unsigned short foo_t;
	char *volatile foo;
	volatile int bar;
	volatile foo_t blech;
	foo = foo;
}
EOCP
if $cc -c $ccflags try.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_volatile
eval $setvar
$rm -f try.*

: see if vsnprintf exists
echo " "
if set vsnprintf val -f d_vsnprintf; eval $csym; $val; then
	echo 'vsnprintf() found.' >&4
	val="$define"
else
	echo 'vsnprintf() NOT found.' >&4
	val="$undef"
fi
set d_vsnprintf
eval $setvar

: see if waitpid exists
set waitpid d_waitpid
eval $inlibc

: check for a __cdecl use
echo " "
$cat >test_cdecl.c <<'EOCP'
#include <stdio.h>
#include <stdlib.h>
#define WIN32_CDECL __cdecl

int WIN32_CDCEL main(int argc, char **argv) {
	exit(0);
}
EOCP

if ($cc $ccflags -o test_cdecl test_cdecl.c && ./test_cdecl) >/dev/null 2>&1 ; then
    cdecl='__cdecl'
    echo 'Your compiler likes __cdecl as a keyword.' >&4
else
    cdecl=''
    echo "Your compiler doesn't grok __cdecl - it probably has a brain." >&4
fi
$rm -f test_cdecl* core

: check for void type
echo " "
echo "Checking to see how well your C compiler groks the void type..." >&4
echo " "
$cat >&4 <<EOM
  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.
    8: generic void pointers.
EOM
echo " "
case "$voidflags" in
'')
	$cat >try.c <<'EOCP'
#if TRY & 1
void sub() {
#else
sub() {
#endif
	extern void moo();	/* function returning void */
	void (*goo)();		/* ptr to func returning void */
#if TRY & 8
	void *hue;		/* generic ptr */
#endif
#if TRY & 2
	void (*foo[10])();
#endif

#if TRY & 4
	if(goo == moo) {
		exit(0);
	}
#endif
	exit(0);
}
main() { sub(); }
EOCP
	if $cc $ccflags -c -DTRY=$defvoidused try.c >.out 2>&1 ; then
		voidflags=$defvoidused
	echo "It appears to support void to the level $package wants ($defvoidused)."
		if $contains warning .out >/dev/null 2>&1; then
			echo "However, you might get some warnings that look like this:"
			$cat .out
		fi
	else
echo "Hmm, your compiler has some difficulty with void. Checking further..." >&4
		if $cc $ccflags -c -DTRY=1 try.c >/dev/null 2>&1; then
			echo "It supports 1..."
			if $cc $ccflags -c -DTRY=3 try.c >/dev/null 2>&1; then
				echo "It also supports 2..."
				if $cc $ccflags -c -DTRY=7 try.c >/dev/null 2>&1; then
					voidflags=7
					echo "And it supports 4 but not 8 definitely."
				else
					echo "It doesn't support 4..."
					if $cc $ccflags -c -DTRY=11 try.c >/dev/null 2>&1; then
						voidflags=11
						echo "But it supports 8."
					else
						voidflags=3
						echo "Neither does it support 8."
					fi
				fi
			else
				echo "It does not support 2..."
				if $cc $ccflags -c -DTRY=13 try.c >/dev/null 2>&1; then
					voidflags=13
					echo "But it supports 4 and 8."
				else
					if $cc $ccflags -c -DTRY=5 try.c >/dev/null 2>&1; then
						voidflags=5
						echo "And it supports 4 but has not heard about 8."
					else
						echo "However it supports 8 but not 4."
					fi
				fi
			fi
		else
			echo "There is no support at all for void."
			voidflags=0
		fi
	fi
esac
case "$voidflags" in
"$defvoidused") ;;
*)
	dflt="$voidflags";
	rp="Your void support flags add up to what?"
	. ./myread
	voidflags="$ans"
	;;
esac
$rm -f try.* .out

: see if this is a malloc.h system
set malloc.h i_malloc
eval $inhdr

: see if stdlib is available
set stdlib.h i_stdlib
eval $inhdr

: compute the return types of malloc and free
echo " "
$cat >malloc.c <<END
#$i_malloc I_MALLOC
#$i_stdlib I_STDLIB
#include <stdio.h>
#include <sys/types.h>
#ifdef I_MALLOC
#include <malloc.h>
#endif
#ifdef I_STDLIB
#include <stdlib.h>
#endif
#ifdef TRY_MALLOC
void *malloc();
#endif
#ifdef TRY_FREE
void free();
#endif
END
case "$malloctype" in
'')
	if $cc $ccflags -c -DTRY_MALLOC malloc.c >/dev/null 2>&1; then
		malloctype='void *'
	else
		malloctype='char *'
	fi
	;;
esac
echo "Your system wants malloc to return '$malloctype', it would seem." >&4

case "$freetype" in
'')
	if $cc $ccflags -c -DTRY_FREE malloc.c >/dev/null 2>&1; then
		freetype='void'
	else
		freetype='int'
	fi
	;;
esac
echo "Your system uses $freetype free(), it would seem." >&4
$rm -f malloc.[co]
: locate a BSD compatible install program
echo " "
echo "Looking for a BSD-compatible install program..." >&4
creatdir=''
case "$install" in
'')
	tryit=''
	for dir in $pth; do
		for file in ginstall installbsd scoinst install; do
			if $test -f $dir/$file; then
				tryit="$tryit $dir/$file"
			fi
		done
	done
	$cat >try.c <<EOC
main()
{
	printf("OK\n");
	exit(0);
}
EOC
	if $cc try.c -o try >/dev/null 2>&1; then
		cp try try.ns
		strip try >/dev/null 2>&1
	else
		echo "(I can't seem to compile a trivial C program -- bypassing.)"
		echo "try" >try
		cp try try.ns
	fi
	$cat >tryinst <<EOS
$startsh
$rm -rf foo d
\$1 -d foo/bar
$mkdir d
\$1 -c -m 764 try.ns d
\$1 -c -s -m 642 try.ns d/try
EOS
	chmod +x tryinst
	$eunicefix tryinst
	dflt=''
	either=''
	for prog in $tryit; do
		$echo $n "Checking $prog... $c"
		./tryinst $prog >/dev/null 2>&1
		if $test -d foo/bar; then
			creatdir="$prog -d"
		fi
		(ls -l d/try >try.ls; ls -l d/try.ns >tryno.ls) 2>/dev/null
		if (cmp -s d/try try && cmp -s d/try.ns try.ns && \
			$contains 'rwxrw-r--' tryno.ls && \
			$contains 'rw-r---w-' try.ls) >/dev/null 2>&1
		then
			dflt="$prog"
			echo "ok, that will do."
			break
		fi
		echo "not good$either."
		either=' either'
		$rm -f try*.ls
	done
	$rm -rf foo d tryinst try try*.ls try.*
	case "$dflt" in
	'')
		dflt='install'
		;;
	esac
	;;
*) dflt="$install";;
esac
$cat <<EOM

I will be requiring a BSD-compatible install program (one that allows
options like -s to strip executables or -m to specify a file mode) to
install $package.

If the question below contains a fully qualified default path, then it
is probably ok. If it is an unqualified name such as 'install', then it
means I was unable to find out a good install program I could use. If
you know of one, please tell me about it.

EOM
fn='/fe~(install)'
rp='Which install program shall I use?'
. ./getfile
install="$ans"

: how can we create nested directories?
echo " "
echo "Ok, let's see how we can create nested directories..." >&4
case "$installdir" in
'')
	case "$creatdir" in
	'')
		$mkdir -p foo/bar >/dev/null 2>&1
		if $test -d foo/bar; then
			echo "Great, we can build them using 'mkdir -p'."
			creatdir='mkdir -p'
		elif eval "$install -d foo/bar"; $test -d foo/bar; then
			creatdir="install -d"
			echo "It looks like '$creatdir' will do it for us."
		fi
		;;
	*)
		eval "$creatdir foo/bar" >/dev/null 2>&1
		if $test -d foo/bar; then
			echo "Ah! We can use '$creatdir' to do just that."
		fi
		;;
	esac
	$rm -rf foo
	case "$creatdir" in
	'')
		echo "Heck! Another ancient system lacking the comfort of modern ones!"
		echo "We have no choice but to use plain old 'mkdir' -- wish me luck!"
		installdir=mkdir
		;;
	*) installdir="$creatdir";;
	esac
	;;
*) echo "As you already told me, '$installdir' should work.";;
esac

echo " "
echo "Checking if your $make program sets \$(MAKE)..." >&4
case "$make_set_make" in
'')
	$sed 's/^X //' > testmake.mak << 'EOF'
Xall:
X 	@echo 'maketemp="$(MAKE)"'
EOF
	case "`$make -f testmake.mak 2>/dev/null`" in
	*maketemp=*) make_set_make='#' ;;
	*)	make_set_make="MAKE=$make" ;;
	esac
	$rm -f testmake.mak
	;;
esac
case "$make_set_make" in
'#') echo "Yup, it does.";;
*) echo "Nope, it doesn't.";;
esac

: see if we have to deal with yellow pages, now NIS.
if $test -d /usr/etc/yp || $test -d /etc/yp; then
	if $test -f /usr/etc/nibindd; then
		echo " "
		echo "I'm fairly confident you're on a NeXT."
		echo " "
		rp='Do you get the passwd file via NetInfo?'
		dflt=y
		case "$passcat" in
		nidump*) ;;
		'') ;;
		*) dflt=n;;
		esac
		. ./myread
		case "$ans" in
		y*) passcat='nidump passwd .'
			;;
		*)	echo "You told me, so don't blame me."
			case "$passcat" in
			nidump*) passcat=''
			esac
			;;
		esac
		echo " "
		rp='Do you get the hosts file via NetInfo?'
		dflt=y
		case "$hostcat" in
		nidump*) ;;
		'') ;;
		*) dflt=n;;
		esac
		. ./myread
		case "$ans" in
		y*) hostcat='nidump hosts .';;
		*)	case "$hostcat" in
			nidump*) hostcat='';;
			esac
			;;
		esac
	fi
	case "$passcat" in
	nidump*) ;;
	*)
		case "$passcat" in
		*ypcat*) dflt=y;;
		'') if $contains '^\+' /etc/passwd >/dev/null 2>&1; then
				dflt=y
			else
				dflt=n
			fi;;
		*) dflt=n;;
		esac
		echo " "
		rp='Are you getting the passwd file via yellow pages?'
		. ./myread
		case "$ans" in
		y*) passcat='ypcat passwd'
			;;
		*)	passcat='cat /etc/passwd'
			;;
		esac
		;;
	esac
	case "$hostcat" in
	nidump*) ;;
	*)
		case "$hostcat" in
		*ypcat*) dflt=y;;
		'') if $contains '^\+' /etc/passwd >/dev/null 2>&1; then
				dflt=y
			else
				dflt=n
			fi;;
		*) dflt=n;;
		esac
		echo " "
		rp='Are you getting the hosts file via yellow pages?'
		. ./myread
		case "$ans" in
		y*) hostcat='ypcat hosts';;
		*) hostcat='cat /etc/hosts';;
		esac
		;;
	esac
fi
case "$hostcat" in
'') hostcat='cat /etc/hosts';;
esac
case "$groupcat" in
'') groupcat='cat /etc/group';;
esac
case "$passcat" in
'') passcat='cat /etc/passwd';;
esac
case "$hostcat" in
'') hostcat='cat /etc/hosts';;
*)  ;;
esac
case "$groupcat" in
'') groupcat='cat /etc/group';;
*)  ;;
esac
case "$passcat" in
'') passcat='cat /etc/passwd';;
*)  ;;
esac

: now get the host name
echo " "
echo "Figuring out host name..." >&4
case "$myhostname" in
'') cont=true
	echo 'Maybe "hostname" will work...'
	if tans=`sh -c hostname 2>&1` ; then
		myhostname=$tans
		phostname=hostname
		cont=''
	fi
	;;
*) cont='';;
esac
if $test "$cont"; then
	if ./xenix; then
		echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
		if tans=`cat /etc/systemid 2>&1` ; then
			myhostname=$tans
			phostname='cat /etc/systemid'
			echo "Whadyaknow.  Xenix always was a bit strange..."
			cont=''
		fi
	elif $test -r /etc/systemid; then
		echo "(What is a non-Xenix system doing with /etc/systemid?)"
	fi
fi
if $test "$cont"; then
	echo 'No, maybe "uuname -l" will work...'
	if tans=`sh -c 'uuname -l' 2>&1` ; then
		myhostname=$tans
		phostname='uuname -l'
	else
		echo 'Strange.  Maybe "uname -n" will work...'
		if tans=`sh -c 'uname -n' 2>&1` ; then
			myhostname=$tans
			phostname='uname -n'
		else
			echo 'Oh well, maybe I can mine it out of whoami.h...'
			if tans=`sh -c $contains' sysname $usrinc/whoami.h' 2>&1` ; then
				myhostname=`echo "$tans" | $sed 's/^.*"\(.*\)"/\1/'`
				phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinc/whoami.h"
			else
				case "$myhostname" in
				'') echo "Does this machine have an identity crisis or something?"
					phostname='';;
				*)
					echo "Well, you said $myhostname before..."
					phostname='echo $myhostname';;
				esac
			fi
		fi
	fi
fi
: you do not want to know about this
set $myhostname
myhostname=$1

: verify guess
if $test "$myhostname" ; then
	dflt=y
	rp='Your host name appears to be "'$myhostname'".'" Right?"
	. ./myread
	case "$ans" in
	y*) ;;
	*) myhostname='';;
	esac
fi

: bad guess or no guess
while $test "X$myhostname" = X ; do
	dflt=''
	rp="Please type the (one word) name of your host:"
	. ./myread
	myhostname="$ans"
done

: translate upper to lower if necessary
case "$myhostname" in
*[A-Z]*)
	echo "(Normalizing case in your host name)"
	myhostname=`echo $myhostname | ./tr '[A-Z]' '[a-z]'`
	;;
esac

case "$myhostname" in
*.*)
	dflt=`expr "X$myhostname" : "X[^.]*\(\..*\)"`
	myhostname=`expr "X$myhostname" : "X\([^.]*\)\."`
	echo "(Trimming domain name from host name--host name is now $myhostname)"
	;;
*) case "$mydomain" in
	'')
		{
			test "X$hostcat" = "Xypcat hosts" &&
			ypmatch "$myhostname" hosts 2>/dev/null |\
				$sed -e 's/[	 ]*#.*//; s/$/ /' > hosts && \
			$test -s hosts
		} || {
		     	$hostcat | $sed -n -e "s/[	 ]*#.*//; s/\$/ /
					/[	 ]$myhostname[	. ]/p" > hosts
		}
		tmp_re="[	. ]"
		$test x`$awk "/[0-9].*[	 ]$myhostname$tmp_re/ { sum++ }
			     END { print sum }" hosts` = x1 || tmp_re="[	 ]"
		dflt=.`$awk "/[0-9].*[	 ]$myhostname$tmp_re/ {for(i=2; i<=NF;i++) print \\\$i}" \
			hosts | $sort | $uniq | \
			$sed -n -e "s/$myhostname\.\([-a-zA-Z0-9_.]\)/\1/p"`
		case `$echo X$dflt` in
		X*\ *)	echo "(Several hosts in /etc/hosts matched hostname)"
			dflt=.
			;;
		X.) echo "(You do not have fully-qualified names in /etc/hosts)"
			;;
		esac
		case "$dflt" in
		.)
			tans=`./loc resolv.conf X /etc /usr/etc`
			if $test -f "$tans"; then
				echo "(Attempting domain name extraction from $tans)"
				dflt=.`$sed -n -e 's/	/ /g' \
				  -e 's/^search  *\([^ ]*\).*/\1/p' $tans \
				  | ./tr '[A-Z]' '[a-z]' 2>/dev/null`
				case "$dflt" in
				.) dflt=.`$sed -n -e 's/	/ /g' \
				     -e 's/^domain  *\([^ ]*\).*/\1/p' $tans \
				     | ./tr '[A-Z]' '[a-z]' 2>/dev/null`
  					;;
				esac
			fi
			;;
		esac
		case "$dflt" in
		.) echo "(No help from resolv.conf either -- attempting clever guess)"
			dflt=.`sh -c domainname 2>/dev/null`
			case "$dflt" in
			'') dflt='.';;
			.nis.*|.yp.*|.main.*) dflt=`echo $dflt | $sed -e 's/^\.[^.]*//'`;;
			esac
			;;
		esac
		case "$dflt" in
		.) echo "(Lost all hope -- silly guess then)"
			dflt='.uucp'
			;;
		esac
		$rm -f hosts
		;;
	*) dflt="$mydomain";;
	esac;;
esac
echo " "
rp="What is your domain name?"
. ./myread
tans="$ans"
case "$ans" in
'') ;;
.*) ;;
*) tans=".$tans";;
esac
mydomain="$tans"

: translate upper to lower if necessary
case "$mydomain" in
*[A-Z]*)
	echo "(Normalizing case in your domain name)"
	mydomain=`echo $mydomain | ./tr '[A-Z]' '[a-z]'`
	;;
esac

: a little sanity check here
case "$phostname" in
'') ;;
*)
	case `$phostname | ./tr '[A-Z]' '[a-z]'` in
	$myhostname$mydomain|$myhostname) ;;
	*)
		case "$phostname" in
		sed*)
			echo "(That doesn't agree with your whoami.h file, by the way.)"
			;;
		*)
			echo "(That doesn't agree with your $phostname command, by the way.)"
			;;
		esac
	;;
	esac
	;;
esac

: define an is-a-typedef? function
typedef='type=$1; var=$2; def=$3; shift; shift; shift; inclist=$@;
case "$inclist" in
"") inclist="sys/types.h";;
esac;
eval "varval=\$$var";
case "$varval" in
"")
	$rm -f temp.c;
	for inc in $inclist; do
		echo "#include <$inc>" >>temp.c;
	done;
	$cppstdin $cppflags $cppminus < temp.c >temp.E 2>/dev/null;
	if $contains $type temp.E >/dev/null 2>&1; then
		eval "$var=\$type";
	else
		eval "$var=\$def";
	fi;
	$rm -f temp.?;;
*) eval "$var=\$varval";;
esac'

: see what type pids are declared as in the kernel
set pid_t pidtype int stdio.h sys/types.h
eval $typedef
dflt="$pidtype"
echo " "
rp="What type are process ids on this system declared as?"
. ./myread
pidtype="$ans"

: see what type is used for size_t
set size_t sizetype 'unsigned int' stdio.h sys/types.h
eval $typedef
dflt="$sizetype"
echo " "
rp="What type is used for the length parameter for string functions?"
. ./myread
sizetype="$ans"

: see if arpa/inet.h has to be included
set arpa/inet.h i_arpainet
eval $inhdr

: see if arpa/nameser.h has to be included
set arpa/nameser.h i_arpanameser
eval $inhdr

: see if errno.h can be included
set errno.h i_errno
eval $inhdr
: see if sys/errno.h can be included
set sys/errno.h i_syserrno
eval $inhdr
: see if this is a sys/file.h system
val=''
set sys/file.h val
eval $inhdr

: do we need to include sys/file.h ?
case "$val" in
"$define")
	echo " "
	if $h_sysfile; then
		val="$define"
		echo "We'll be including <sys/file.h>." >&4
	else
		val="$undef"
		echo "We won't be including <sys/file.h>." >&4
	fi
	;;
*)
	h_sysfile=false
	;;
esac
set i_sysfile
eval $setvar

: see if fcntl.h is there
val=''
set fcntl.h val
eval $inhdr

: see if we can include fcntl.h
case "$val" in
"$define")
	echo " "
	if $h_fcntl; then
		val="$define"
		echo "We'll be including <fcntl.h>." >&4
	else
		val="$undef"
		if $h_sysfile; then
	echo "We don't need to include <fcntl.h> if we include <sys/file.h>." >&4
		else
			echo "We won't be including <fcntl.h>." >&4
		fi
	fi
	;;
*)
	h_fcntl=false
	val="$undef"
	;;
esac
set i_fcntl
eval $setvar

: see if locale.h is available
set locale.h i_locale
eval $inhdr

: see if memory.h is available.
val=''
set memory.h val
eval $inhdr

: See if it conflicts with string.h
case "$val" in
$define)
	case "$strings" in
	'') ;;
	*)
		$cppstdin $cppflags $cppminus < "$strings" > mem.h
		if $contains 'memcpy' mem.h >/dev/null 2>&1; then
			echo " "
			echo "We won't be including <memory.h>."
			val="$undef"
		fi
		$rm -f mem.h
		;;
	esac
esac
set i_memory
eval $setvar

: see if netdb.h can be included
set netdb.h i_netdb
eval $inhdr
: see if setjmp.h can be included
set setjmp.h i_setjmp
eval $inhdr
: see if stdarg is available
echo " "
if $test "`./findhdr stdarg.h`"; then
	echo "<stdarg.h> found." >&4
	valstd="$define"
else
	echo "<stdarg.h> NOT found." >&4
	valstd="$undef"
fi

: see if varags is available
echo " "
if $test "`./findhdr varargs.h`"; then
	echo "<varargs.h> found." >&4
else
	echo "<varargs.h> NOT found, but that's ok (I hope)." >&4
fi

: set up the varargs testing programs
$cat > varargs.c <<EOP
#ifdef I_STDARG
#include <stdarg.h>
#endif
#ifdef I_VARARGS
#include <varargs.h>
#endif

#ifdef I_STDARG
int f(char *p, ...)
#else
int f(va_alist)
va_dcl
#endif
{
	va_list ap;
#ifndef I_STDARG
	char *p;
#endif
#ifdef I_STDARG
	va_start(ap,p);
#else
	va_start(ap);
	p = va_arg(ap, char *);
#endif
	va_end(ap);
}
EOP
$cat > varargs <<EOP
$startsh
if $cc -c $ccflags $ldflags -D\$1 varargs.c >/dev/null 2>&1; then
	echo "true"
else
	echo "false"
fi
$rm -f varargs$_o
EOP
chmod +x varargs

: now check which varargs header should be included
echo " "
i_varhdr=''
case "$valstd" in
"$define")
	if `./varargs I_STDARG`; then
		val='stdarg.h'
	elif `./varargs I_VARARGS`; then
		val='varargs.h'
	fi
	;;
*)
	if `./varargs I_VARARGS`; then
		val='varargs.h'
	fi
	;;
esac
case "$val" in
'')
echo "I could not find the definition for va_dcl... You have problems..." >&4
	val="$undef"; set i_stdarg; eval $setvar
	val="$undef"; set i_varargs; eval $setvar
	;;
*) 
	set i_varhdr
	eval $setvar
	case "$i_varhdr" in
	stdarg.h)
		val="$define"; set i_stdarg; eval $setvar
		val="$undef"; set i_varargs; eval $setvar
		;;
	varargs.h)
		val="$undef"; set i_stdarg; eval $setvar
		val="$define"; set i_varargs; eval $setvar
		;;
	esac
	echo "We'll include <$i_varhdr> to get va_dcl definition." >&4;;
esac
$rm -f varargs*

: see if stddef is available
set stddef.h i_stddef
eval $inhdr

: see if sys/mman.h has to be included
set sys/mman.h i_sysmman
eval $inhdr

: see if sys/page.h has to be included
set sys/page.h i_syspage
eval $inhdr

: see if this is a sys/param system
set sys/param.h i_sysparam
eval $inhdr

: see if sys/resource.h has to be included
set sys/resource.h i_sysresrc
eval $inhdr

: see if sys/select.h has to be included
set sys/select.h i_sysselct
eval $inhdr

: see if sys/stat.h is available
set sys/stat.h i_sysstat
eval $inhdr

: see if we should include time.h, sys/time.h, or both
echo " "
echo "Testing to see if we should include <time.h>, <sys/time.h> or both." >&4
$echo $n "I'm now running the test program...$c"
$cat >try.c <<'EOCP'
#include <sys/types.h>
#ifdef I_TIME
#include <time.h>
#endif
#ifdef I_SYSTIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif
#include <sys/time.h>
#endif
#ifdef I_SYSSELECT
#include <sys/select.h>
#endif
main()
{
	struct tm foo;
#ifdef S_TIMEVAL
	struct timeval bar;
#endif
#ifdef S_TIMEZONE
	struct timezone tzp;
#endif
	if (foo.tm_sec == foo.tm_sec)
		exit(0);
#ifdef S_TIMEVAL
	if (bar.tv_sec == bar.tv_sec)
		exit(0);
#endif
	exit(1);
}
EOCP
flags=''
for s_timezone in '-DS_TIMEZONE' ''; do
sysselect=''
for s_timeval in '-DS_TIMEVAL' ''; do
for i_systimek in '' '-DSYSTIMEKERNEL'; do
for i_time in '' '-DI_TIME'; do
for i_systime in '-DI_SYSTIME' ''; do
	case "$flags" in
	'') $echo $n ".$c"
		if $cc $ccflags \
		$i_time $i_systime $i_systimek $sysselect $s_timeval $s_timezone \
		try.c -o try >/dev/null 2>&1 ; then
			set X $i_time $i_systime $i_systimek $sysselect $s_timeval
			shift
			flags="$*"
			echo " "
			$echo $n "Succeeded with $flags$c"
		fi
		;;
	esac
done
done
done
done
done
timeincl=''
echo " "
case "$flags" in
*SYSTIMEKERNEL*) i_systimek="$define"
	timeincl=`./findhdr sys/time.h`
	echo "We'll include <sys/time.h> with KERNEL defined." >&4;;
*) i_systimek="$undef";;
esac
case "$flags" in
*I_TIME*) i_time="$define"
	timeincl=`./findhdr time.h`" $timeincl"
	echo "We'll include <time.h>." >&4;;
*) i_time="$undef";;
esac
case "$flags" in
*I_SYSTIME*) i_systime="$define"
	timeincl=`./findhdr sys/time.h`" $timeincl"
	echo "We'll include <sys/time.h>." >&4;;
*) i_systime="$undef";;
esac
$rm -f try.c try

: see if sys/vlimit.h has to be included
set sys/vlimit.h i_sysvlimit
eval $inhdr

: see if this is a syswait system
set sys/wait.h i_syswait
eval $inhdr

: determine the name of a reasonable mailer
case "$mailer" in
'')
	if $test -f "$sendmail"; then
		dflt="$sendmail"
	elif $test -f "$smail"; then
		dflt="$smail"
	elif $test -f "$rmail"; then
		dflt="$rmail"
	elif $test -f /bin/mail; then
		dflt=/bin/mail
	else
		dflt=$mail
	fi
	;;
*)  dflt="$mailer";;
esac
$cat <<EOM

Later on, I'm going to offer you the chance to subscribe (or unsubscribe)
to the $package mailing list. In order to do that, I need to figure out
how to send mail, your name, and a few other things. 

I need the full pathname of the program used to deliver mail on your system.
A typical answer would be /usr/lib/sendmail or /bin/rmail, but you may choose
any other program, as long as it can be fed from standard input and will
honour any user-supplied headers.

EOM
fn=f
rp='Mail transport agent to be used?'
. ./getfile
mailer="$ans"

: find out how to find out full name
case "$d_berknames" in
"$define")
	dflt=y;;
"$undef")
	dflt=n;;
*)
	if ./bsd; then
		dflt=y
	elif ./xenix; then
		dflt=y
	elif $test "x$osname" = "xlinux"; then
		dflt=y
	else
		dflt=n
	fi
	;;
esac
$cat <<'EOM'

Does your /etc/passwd file keep full names in Berkeley/V7 format (name first
thing after ':' in GCOS field)?  In that case, a typical entry in the password
file looks like this:

    guest:**paswword**:10:100:Mister Guest User:/usr/users:/bin/sh
                              ^^^^^^^^^^^^^^^^^
EOM
rp="Berkeley/V7 format for full name in /etc/passwd?"
. ./myread
case "$ans" in
y*) d_passnames="$define"
	d_berknames="$define"
	d_usgnames="$undef"
	nametype=bsd
	;;
*)
	case "$d_usgnames" in
	"$define") dflt=y;;
	"$undef") dflt=n;;
	*)
		if ./usg; then
			dflt=y
		else
			dflt=n
		fi
		;;
	esac
$cat <<'EOM'

Does your passwd file keep full names in USG format (name sandwiched between a
'-' and a '(')?  In that case, a typical entry in the password file looks like
this:

    guest:**paswword**:10:100:000-Mister Guest User(000):/usr/users:/bin/sh
                                  ^^^^^^^^^^^^^^^^^
EOM
	rp="USG format for full name in /etc/passwd?"
	. ./myread
	case "$ans" in
	n*) echo "Full name will be taken from ~/.fullname"
		d_passnames="$undef"
		d_berknames="$undef"
		d_usgnames="$undef"
		nametype=other
		;;
	*)
		d_passnames="$define"
		d_berknames="$undef"
		d_usgnames="$define"
		nametype=usg
		;;
	esac;;
esac

: figure out their full name
case "$NAME" in
'') case "$nametype" in
	other)
		fn=`./filexp ~/.fullname`
		xxx=usg
		$test -f $fn && xxx=other
		;;
	*)
		xxx="$nametype"
		;;
	esac

	case "$xxx" in
	bsd)
		cf_name=`$passcat | grep "^$cf_by:" | \
			sed -e 's/^[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):.*/\1/' \
			-e 's/,.*//'`
		;;
    usg)
		cf_name=`$passcat | grep "^$cf_by:" | \
			sed -e 's/^[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):.*/\1/' \
			-e 's/[^-]*-\(.*\)(.*)/\1/'`
		;;
	*)
		cf_name=`$cat $fn`
		;;
	esac
	;;
*)
	cf_name="$NAME"
	;;
esac
echo " "
echo "Pleased to meet you, $cf_name."

$cat <<EOM

I need to get your e-mail address in Internet format if possible, i.e.
something like user@host.domain. Please answer accurately since I have
no easy means to double check it. The default value provided below
is most probably close to the reality but may not be valid from outside
your organization...

EOM
cont=x
while test "$cont"; do
	case "$cf_email" in
	'') dflt="$cf_by@$myhostname$mydomain";;
	*) dflt="$cf_email";;
	esac
	rp='What is your e-mail address?'
	. ./myread
	cf_email="$ans"
	case "$cf_email" in
	*@*.*) cont='' ;;
	*)
		rp='Address does not look like an Internet one.  Use it anyway?'
		case "$fastread" in
		yes) dflt=y ;;
		*) dflt=n ;;
		esac
		. ./myread
		case "$ans" in
		y*) cont='' ;;
		*) echo " " ;;
		esac
		;;
	esac
done

: offer to join the mailing list
list_request=''
list_sub=""
list_unsub=""
list_name=""
$cat <<EOM

There is a mailing list for discussion about $package and related issues.
This is the preferred place to ask questions about the program and discuss
modifications and additions with the author and other users.  If you are able
to send mail to the Internet, you are encouraged to subscribe.  You need only
ever subscribe once, and you can unsubscribe automatically at any time in the
future.  If you have already subscribed and you wish to unsubscribe now, you
may do so by answering "unsubscribe".  Answer "subscribe" to subscribe to the
list.

EOM
rp="Subscribe to or unsubscribe from the $list_name mailing list?"
dflt=neither
. ./myread
case "$ans" in
[sS]*)	$cat <<EOM

You will be sent a message from the list server to let you know when your
subscription has been successful and telling you how to submit articles and
how to unsubscribe again when necessary. You may also unsubscribe by running
this script again and asking it to do so for you.

EOM
	echo "Sending mail to subscribe you to the $list_name list..." >&4
	$mailer $list_request <<EOM >/dev/null 2>&1
To: $list_request
Subject: Subscription request by configure

$list_sub
EOM
	;;
[uU]*)	echo "Sending mail to unsubscribe you from the $list_name list..." >&4
	$mailer $list_request <<EOM >/dev/null 2>&1
To: $list_request
Subject: Unsubscription request by configure

$list_unsub
EOM
	;;
esac

: end of configuration questions
echo " "
echo "End of configuration questions."
echo " "

: back to where it started
if test -d ../UU; then
	cd ..
fi

: configuration may be patched via a 'config.over' file
if $test -f config.over; then
	echo " "
	dflt=y
	rp='I see a config.over file.  Do you wish to load it?'
	. UU/myread
	case "$ans" in
	n*) echo "OK, I'll ignore it.";;
	*)	. ./config.over
		echo "Configuration override changes have been loaded."
		;;
	esac
fi

: in case they want portability, strip down executable paths
case "$d_portable" in
"$define")
	echo " "
	echo "Stripping down executable paths..." >&4
	for file in $loclist $trylist; do
		eval $file="\$file"
	done
	;;
esac

: create config.sh file
echo " "
echo "Creating config.sh..." >&4
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script. It holds all the
# definitions figured out by Configure. Should you modify one of these values,
# do not forget to propagate your changes by running "Configure -der". You may
# instead choose to run each of the .SH files by yourself, or "Configure -S".
#

# Package name      : $package
# Source directory  : $src
# Configuration time: $cf_time
# Configured by     : $cf_by
# Target system     : $myuname

Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
Mcc='$Mcc'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
ar='$ar'
archobjs='$archobjs'
awk='$awk'
bash='$bash'
bison='$bison'
byacc='$byacc'
c='$c'
cat='$cat'
cc='$cc'
ccflags='$ccflags'
cdecl='$cdecl'
cf_by='$cf_by'
cf_email='$cf_email'
cf_name='$cf_name'
cf_time='$cf_time'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
comm='$comm'
compress='$compress'
contains='$contains'
cp='$cp'
cpio='$cpio'
cpp='$cpp'
cppflags='$cppflags'
cpplast='$cpplast'
cppminus='$cppminus'
cpprun='$cpprun'
cppstdin='$cppstdin'
cryptlib='$cryptlib'
csh='$csh'
d_access='$d_access'
d_argsinfp='$d_argsinfp'
d_assert='$d_assert'
d_attribut='$d_attribut'
d_bcopy='$d_bcopy'
d_berknames='$d_berknames'
d_bindtextdomain='$d_bindtextdomain'
d_bsd='$d_bsd'
d_bsdsetpgrp='$d_bsdsetpgrp'
d_bzero='$d_bzero'
d_const='$d_const'
d_crypt='$d_crypt'
d_eunice='$d_eunice'
d_force_ipv4='$d_force_ipv4'
d_fpsetmask='$d_fpsetmask'
d_fpsetround='$d_fpsetround'
d_gaistr='$d_gaistr'
d_getadinf='$d_getadinf'
d_getdate='$d_getdate'
d_gethbynm2='$d_gethbynm2'
d_getnminf='$d_getnminf'
d_getpagsz='$d_getpagsz'
d_getprior='$d_getprior'
d_gettblsz='$d_gettblsz'
d_gettext='$d_gettext'
d_gnulibc='$d_gnulibc'
d_huge='$d_huge'
d_huge_val='$d_huge_val'
d_ieee='$d_ieee'
d_in2p='$d_in2p'
d_index='$d_index'
d_int_max='$d_int_max'
d_internet='$d_internet'
d_ipv6='$d_ipv6'
d_itimer='$d_itimer'
d_keepalive='$d_keepalive'
d_keepidle='$d_keepidle'
d_keepsig='$d_keepsig'
d_lrand48='$d_lrand48'
d_maxdouble='$d_maxdouble'
d_maxint='$d_maxint'
d_memcpy='$d_memcpy'
d_memmove='$d_memmove'
d_memset='$d_memset'
d_mymalloc='$d_mymalloc'
d_mysql='$d_mysql'
d_newstyle='$d_newstyle'
d_oldsock='$d_oldsock'
d_open3='$d_open3'
d_openssl='$d_openssl'
d_passnames='$d_passnames'
d_portable='$d_portable'
d_rand='$d_rand'
d_random='$d_random'
d_rename='$d_rename'
d_rlimit='$d_rlimit'
d_rusage='$d_rusage'
d_select='$d_select'
d_sendmail='$d_sendmail'
d_setlocale='$d_setlocale'
d_setpgid='$d_setpgid'
d_setpgrp='$d_setpgrp'
d_setprior='$d_setprior'
d_sigaction='$d_sigaction'
d_sigchld='$d_sigchld'
d_sigcld='$d_sigcld'
d_signalproto='$d_signalproto'
d_sigprocmask='$d_sigprocmask'
d_snprintf='$d_snprintf'
d_socket='$d_socket'
d_socklen='$d_socklen'
d_sockpair='$d_sockpair'
d_strccmp='$d_strccmp'
d_strchr='$d_strchr'
d_strcoll='$d_strcoll'
d_strdup='$d_strdup'
d_strxfrm='$d_strxfrm'
d_sysconf='$d_sysconf'
d_sysctl='$d_sysctl'
d_sysctlbyname='$d_sysctlbyname'
d_tcl='$d_tcl'
d_textdomain='$d_textdomain'
d_timelocal='$d_timelocal'
d_toupper='$d_toupper'
d_uptime='$d_uptime'
d_urandom='$d_urandom'
d_usgnames='$d_usgnames'
d_uwait3='$d_uwait3'
d_uwait='$d_uwait'
d_voidsig='$d_voidsig'
d_voidtty='$d_voidtty'
d_volatile='$d_volatile'
d_vsnprintf='$d_vsnprintf'
d_waitpid='$d_waitpid'
d_xenix='$d_xenix'
date='$date'
defvoidused='$defvoidused'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
eunicefix='$eunicefix'
expr='$expr'
find='$find'
firstmakefile='$firstmakefile'
flex='$flex'
freetype='$freetype'
gcc='$gcc'
gccversion='$gccversion'
glibpth='$glibpth'
grep='$grep'
groupcat='$groupcat'
gzip='$gzip'
h_fcntl='$h_fcntl'
h_sysfile='$h_sysfile'
hint='$hint'
hostcat='$hostcat'
i_arpainet='$i_arpainet'
i_arpanameser='$i_arpanameser'
i_bsdioctl='$i_bsdioctl'
i_crypt='$i_crypt'
i_errno='$i_errno'
i_fcntl='$i_fcntl'
i_floatingpoint='$i_floatingpoint'
i_libintl='$i_libintl'
i_limits='$i_limits'
i_locale='$i_locale'
i_malloc='$i_malloc'
i_memory='$i_memory'
i_netdb='$i_netdb'
i_niin='$i_niin'
i_nitcp='$i_nitcp'
i_setjmp='$i_setjmp'
i_sgtty='$i_sgtty'
i_stdarg='$i_stdarg'
i_stddef='$i_stddef'
i_stdlib='$i_stdlib'
i_string='$i_string'
i_syserrno='$i_syserrno'
i_sysfile='$i_sysfile'
i_sysfilio='$i_sysfilio'
i_sysin='$i_sysin'
i_sysioctl='$i_sysioctl'
i_sysmman='$i_sysmman'
i_syspage='$i_syspage'
i_sysparam='$i_sysparam'
i_sysresrc='$i_sysresrc'
i_sysselct='$i_sysselct'
i_syssock='$i_syssock'
i_syssockio='$i_syssockio'
i_sysstat='$i_sysstat'
i_systime='$i_systime'
i_systimek='$i_systimek'
i_systypes='$i_systypes'
i_sysvlimit='$i_sysvlimit'
i_syswait='$i_syswait'
i_tcl='$i_tcl'
i_termio='$i_termio'
i_termios='$i_termios'
i_time='$i_time'
i_unistd='$i_unistd'
i_values='$i_values'
i_varargs='$i_varargs'
i_varhdr='$i_varhdr'
incpath='$incpath'
inews='$inews'
install='$install'
installdir='$installdir'
ksh='$ksh'
ldflags='$ldflags'
less='$less'
libc='$libc'
libmysqlclient='$libmysqlclient'
libpth='$libpth'
libs='$libs'
libssl='$libssl'
line='$line'
lint='$lint'
lkflags='$lkflags'
ln='$ln'
lns='$lns'
locincpth='$locincpth'
loclibpth='$loclibpth'
lp='$lp'
lpr='$lpr'
ls='$ls'
mail='$mail'
mailer='$mailer'
mailx='$mailx'
make='$make'
make_set_make='$make_set_make'
mallocobj='$mallocobj'
mallocsrc='$mallocsrc'
malloctype='$malloctype'
mips='$mips'
mips_type='$mips_type'
mkdir='$mkdir'
more='$more'
mv='$mv'
mydomain='$mydomain'
myhostname='$myhostname'
myuname='$myuname'
n='$n'
nametype='$nametype'
nm_opt='$nm_opt'
nm_so_opt='$nm_so_opt'
nofile='$nofile'
nroff='$nroff'
optimize='$optimize'
osname='$osname'
osvers='$osvers'
package='$package'
pagesize='$pagesize'
passcat='$passcat'
perl='$perl'
pg='$pg'
phostname='$phostname'
pidtype='$pidtype'
plibpth='$plibpth'
pmake='$pmake'
pr='$pr'
prototype='$prototype'
rm='$rm'
rmail='$rmail'
runnm='$runnm'
sed='$sed'
sendmail='$sendmail'
sh='$sh'
shar='$shar'
sharpbang='$sharpbang'
shsharp='$shsharp'
signal_t='$signal_t'
sizetype='$sizetype'
sleep='$sleep'
smail='$smail'
so='$so'
sockethdr='$sockethdr'
socketlib='$socketlib'
sort='$sort'
spackage='$spackage'
spitshell='$spitshell'
src='$src'
startsh='$startsh'
strings='$strings'
submit='$submit'
sysman='$sysman'
tablesize='$tablesize'
tail='$tail'
tar='$tar'
tbl='$tbl'
test='$test'
timeincl='$timeincl'
touch='$touch'
tr='$tr'
troff='$troff'
uname='$uname'
uniq='$uniq'
uptime='$uptime'
usemymalloc='$usemymalloc'
usenm='$usenm'
usrinc='$usrinc'
uuname='$uuname'
vi='$vi'
voidflags='$voidflags'
warnings='$warnings'
xlibpth='$xlibpth'
zcat='$zcat'
zip='$zip'
EOT

: add special variables
$test -f $src/patchlevel.h && \
awk '/^#define/ {printf "%s=%s\n",$2,$3}' $src/patchlevel.h >>config.sh
echo "CONFIG=true" >>config.sh

: propagate old symbols
if $test -f UU/config.sh; then
	<UU/config.sh sort | uniq >UU/oldconfig.sh
	sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
	sort | uniq -u >UU/oldsyms
	set X `cat UU/oldsyms`
	shift
	case $# in
	0) ;;
	*)
		cat <<EOM
Hmm...You had some extra variables I don't know about...I'll try to keep 'em...
EOM
		echo "# Variables propagated from previous config.sh file." >>config.sh
		for sym in `cat UU/oldsyms`; do
			echo "    Propagating $hint variable "'$'"$sym..."
			eval 'tmp="$'"${sym}"'"'
			echo "$tmp" | \
				sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
		done
		;;
	esac
fi

: preserve RCS keywords in files with variable substitution, grrr
Id='$Id'

: Finish up by extracting the .SH files
case "$alldone" in
exit)
	$rm -rf UU
	echo "Done."
	exit 0
	;;
cont)
	;;
'')
	dflt=''
	nostick=true
	$cat <<EOM

If you'd like to make any changes to the config.sh file before I begin
to configure things, do it as a shell escape now (e.g. !vi config.sh).

EOM
	rp="Press return or use a shell escape to edit config.sh:"
	. UU/myread
	nostick=''
	case "$ans" in
	'') ;;
	*) : in case they cannot read
		sh 1>&4 -c "$ans";;
	esac
	;;
esac

: if this fails, just run all the .SH files by hand
. ./config.sh

echo " "
exec 1>&4
. ./UU/extract

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
	dflt=y
	case "$silent" in
	true) ;;
	*)
		$cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
		;;
	esac
	rp="Run make depend now?"
	. UU/myread
	case "$ans" in
	y*)
		make depend && echo "Now you must run a make."
		;;
	*)
		echo "You must run 'make depend' then 'make'."
		;;
	esac
elif test -f [Mm]akefile; then
	echo " "
	echo "Now you must run a make."
else
	echo "Done."
fi

$rm -f kit*isdone ark*isdone
$rm -rf UU

: End of Configure

